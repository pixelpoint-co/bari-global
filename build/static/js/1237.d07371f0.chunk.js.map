{"version":3,"file":"static/js/1237.d07371f0.chunk.js","mappings":"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","sources":["../node_modules/lucide-react/src/icons/arrow-left.ts","../node_modules/lucide-react/src/icons/arrow-right.ts","../node_modules/lucide-react/src/icons/chevron-down.ts","../node_modules/lucide-react/src/icons/search.ts","../node_modules/@radix-ui/react-avatar/src/Avatar.tsx","../node_modules/@radix-ui/react-compose-refs/src/composeRefs.tsx","../node_modules/@radix-ui/react-context/src/createContext.tsx","../node_modules/@radix-ui/primitive/src/primitive.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/useControllableState.tsx","../node_modules/@radix-ui/react-direction/src/Direction.tsx","../node_modules/@radix-ui/react-presence/src/Presence.tsx","../node_modules/@radix-ui/react-presence/src/useStateMachine.tsx","../node_modules/@radix-ui/react-id/src/id.tsx","../node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-context/src/createContext.tsx","../node_modules/@radix-ui/react-collection/src/Collection.tsx","../node_modules/@radix-ui/react-dismissable-layer/src/DismissableLayer.tsx","../node_modules/@radix-ui/react-use-escape-keydown/src/useEscapeKeydown.tsx","../node_modules/@radix-ui/react-use-previous/src/usePrevious.tsx","../node_modules/@radix-ui/react-visually-hidden/src/VisuallyHidden.tsx","../node_modules/@radix-ui/react-navigation-menu/src/NavigationMenu.tsx","../node_modules/@radix-ui/react-primitive/src/Primitive.tsx","../node_modules/@radix-ui/react-slot/src/Slot.tsx","../node_modules/@radix-ui/react-use-callback-ref/src/useCallbackRef.tsx","../node_modules/@radix-ui/react-use-layout-effect/src/useLayoutEffect.tsx","../node_modules/class-variance-authority/node_modules/clsx/dist/clsx.mjs","../node_modules/embla-carousel-reactive-utils/src/components/utils.ts","../node_modules/embla-carousel/src/components/utils.ts","../node_modules/embla-carousel/src/components/EventStore.ts","../node_modules/embla-carousel/src/components/Animations.ts","../node_modules/embla-carousel/src/components/Limit.ts","../node_modules/embla-carousel/src/components/Counter.ts","../node_modules/embla-carousel/src/components/DragHandler.ts","../node_modules/embla-carousel/src/components/DragTracker.ts","../node_modules/embla-carousel/src/components/ResizeHandler.ts","../node_modules/embla-carousel/src/components/ScrollBounds.ts","../node_modules/embla-carousel/src/components/ScrollLooper.ts","../node_modules/embla-carousel/src/components/ScrollTarget.ts","../node_modules/embla-carousel/src/components/SlideFocus.ts","../node_modules/embla-carousel/src/components/Vector1d.ts","../node_modules/embla-carousel/src/components/Translate.ts","../node_modules/embla-carousel/src/components/SlideLooper.ts","../node_modules/embla-carousel/src/components/SlidesHandler.ts","../node_modules/embla-carousel/src/components/SlidesInView.ts","../node_modules/embla-carousel/src/components/SlidesToScroll.ts","../node_modules/embla-carousel/src/components/Engine.ts","../node_modules/embla-carousel/src/components/NodeRects.ts","../node_modules/embla-carousel/src/components/Axis.ts","../node_modules/embla-carousel/src/components/PercentOfView.ts","../node_modules/embla-carousel/src/components/Alignment.ts","../node_modules/embla-carousel/src/components/SlideSizes.ts","../node_modules/embla-carousel/src/components/ScrollSnaps.ts","../node_modules/embla-carousel/src/components/ScrollContain.ts","../node_modules/embla-carousel/src/components/ScrollLimit.ts","../node_modules/embla-carousel/src/components/ScrollBody.ts","../node_modules/embla-carousel/src/components/ScrollTo.ts","../node_modules/embla-carousel/src/components/ScrollProgress.ts","../node_modules/embla-carousel/src/components/SlideRegistry.ts","../node_modules/embla-carousel/src/components/Options.ts","../node_modules/embla-carousel/src/components/OptionsHandler.ts","../node_modules/embla-carousel/src/components/EmblaCarousel.ts","../node_modules/embla-carousel/src/components/PluginsHandler.ts","../node_modules/embla-carousel/src/components/EventHandler.ts","../node_modules/embla-carousel-react/src/components/useEmblaCarousel.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ArrowLeft\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTIgMTktNy03IDctNyIgLz4KICA8cGF0aCBkPSJNMTkgMTJINSIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/arrow-left\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ArrowLeft = createLucideIcon('ArrowLeft', [\n  ['path', { d: 'm12 19-7-7 7-7', key: '1l729n' }],\n  ['path', { d: 'M19 12H5', key: 'x3x0zl' }],\n]);\n\nexport default ArrowLeft;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ArrowRight\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNSAxMmgxNCIgLz4KICA8cGF0aCBkPSJtMTIgNSA3IDctNyA3IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/arrow-right\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ArrowRight = createLucideIcon('ArrowRight', [\n  ['path', { d: 'M5 12h14', key: '1ays0h' }],\n  ['path', { d: 'm12 5 7 7-7 7', key: 'xquz4c' }],\n]);\n\nexport default ArrowRight;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ChevronDown\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtNiA5IDYgNiA2LTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/chevron-down\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronDown = createLucideIcon('ChevronDown', [\n  ['path', { d: 'm6 9 6 6 6-6', key: 'qrunsl' }],\n]);\n\nexport default ChevronDown;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Search\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4IiAvPgogIDxwYXRoIGQ9Im0yMSAyMS00LjMtNC4zIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/search\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Search = createLucideIcon('Search', [\n  ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],\n  ['path', { d: 'm21 21-4.3-4.3', key: '1qie3q' }],\n]);\n\nexport default Search;\n","import * as React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Avatar\n * -----------------------------------------------------------------------------------------------*/\n\nconst AVATAR_NAME = 'Avatar';\n\ntype ScopedProps<P> = P & { __scopeAvatar?: Scope };\nconst [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);\n\ntype ImageLoadingStatus = 'idle' | 'loading' | 'loaded' | 'error';\n\ntype AvatarContextValue = {\n  imageLoadingStatus: ImageLoadingStatus;\n  onImageLoadingStatusChange(status: ImageLoadingStatus): void;\n};\n\nconst [AvatarProvider, useAvatarContext] = createAvatarContext<AvatarContextValue>(AVATAR_NAME);\n\ntype AvatarElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface AvatarProps extends PrimitiveSpanProps {}\n\nconst Avatar = React.forwardRef<AvatarElement, AvatarProps>(\n  (props: ScopedProps<AvatarProps>, forwardedRef) => {\n    const { __scopeAvatar, ...avatarProps } = props;\n    const [imageLoadingStatus, setImageLoadingStatus] = React.useState<ImageLoadingStatus>('idle');\n    return (\n      <AvatarProvider\n        scope={__scopeAvatar}\n        imageLoadingStatus={imageLoadingStatus}\n        onImageLoadingStatusChange={setImageLoadingStatus}\n      >\n        <Primitive.span {...avatarProps} ref={forwardedRef} />\n      </AvatarProvider>\n    );\n  }\n);\n\nAvatar.displayName = AVATAR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AvatarImage\n * -----------------------------------------------------------------------------------------------*/\n\nconst IMAGE_NAME = 'AvatarImage';\n\ntype AvatarImageElement = React.ElementRef<typeof Primitive.img>;\ntype PrimitiveImageProps = React.ComponentPropsWithoutRef<typeof Primitive.img>;\ninterface AvatarImageProps extends PrimitiveImageProps {\n  onLoadingStatusChange?: (status: ImageLoadingStatus) => void;\n}\n\nconst AvatarImage = React.forwardRef<AvatarImageElement, AvatarImageProps>(\n  (props: ScopedProps<AvatarImageProps>, forwardedRef) => {\n    const { __scopeAvatar, src, onLoadingStatusChange = () => {}, ...imageProps } = props;\n    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);\n    const imageLoadingStatus = useImageLoadingStatus(src, imageProps.referrerPolicy);\n    const handleLoadingStatusChange = useCallbackRef((status: ImageLoadingStatus) => {\n      onLoadingStatusChange(status);\n      context.onImageLoadingStatusChange(status);\n    });\n\n    useLayoutEffect(() => {\n      if (imageLoadingStatus !== 'idle') {\n        handleLoadingStatusChange(imageLoadingStatus);\n      }\n    }, [imageLoadingStatus, handleLoadingStatusChange]);\n\n    return imageLoadingStatus === 'loaded' ? (\n      <Primitive.img {...imageProps} ref={forwardedRef} src={src} />\n    ) : null;\n  }\n);\n\nAvatarImage.displayName = IMAGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AvatarFallback\n * -----------------------------------------------------------------------------------------------*/\n\nconst FALLBACK_NAME = 'AvatarFallback';\n\ntype AvatarFallbackElement = React.ElementRef<typeof Primitive.span>;\ninterface AvatarFallbackProps extends PrimitiveSpanProps {\n  delayMs?: number;\n}\n\nconst AvatarFallback = React.forwardRef<AvatarFallbackElement, AvatarFallbackProps>(\n  (props: ScopedProps<AvatarFallbackProps>, forwardedRef) => {\n    const { __scopeAvatar, delayMs, ...fallbackProps } = props;\n    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);\n    const [canRender, setCanRender] = React.useState(delayMs === undefined);\n\n    React.useEffect(() => {\n      if (delayMs !== undefined) {\n        const timerId = window.setTimeout(() => setCanRender(true), delayMs);\n        return () => window.clearTimeout(timerId);\n      }\n    }, [delayMs]);\n\n    return canRender && context.imageLoadingStatus !== 'loaded' ? (\n      <Primitive.span {...fallbackProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nAvatarFallback.displayName = FALLBACK_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useImageLoadingStatus(src?: string, referrerPolicy?: React.HTMLAttributeReferrerPolicy) {\n  const [loadingStatus, setLoadingStatus] = React.useState<ImageLoadingStatus>('idle');\n\n  useLayoutEffect(() => {\n    if (!src) {\n      setLoadingStatus('error');\n      return;\n    }\n\n    let isMounted = true;\n    const image = new window.Image();\n\n    const updateStatus = (status: ImageLoadingStatus) => () => {\n      if (!isMounted) return;\n      setLoadingStatus(status);\n    };\n\n    setLoadingStatus('loading');\n    image.onload = updateStatus('loaded');\n    image.onerror = updateStatus('error');\n    image.src = src;\n    if (referrerPolicy) {\n      image.referrerPolicy = referrerPolicy;\n    }\n\n    return () => {\n      isMounted = false;\n    };\n  }, [src, referrerPolicy]);\n\n  return loadingStatus;\n}\nconst Root = Avatar;\nconst Image = AvatarImage;\nconst Fallback = AvatarFallback;\n\nexport {\n  createAvatarScope,\n  //\n  Avatar,\n  AvatarImage,\n  AvatarFallback,\n  //\n  Root,\n  Image,\n  Fallback,\n};\nexport type { AvatarProps, AvatarImageProps, AvatarFallbackProps };\n","import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node));\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n","import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n","function composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !((event as unknown) as Event).defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n","import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n}: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const setter = nextValue as SetStateFn<T>;\n        const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n        if (value !== prop) handleChange(value as T);\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, handleChange]\n  );\n\n  return [value, setValue] as const;\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\n\nexport { useControllableState };\n","import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n//  https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We `toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)['useId'.toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\nexport { useId };\n","import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  function Provider(props: ContextValueType & { children: React.ReactNode }) {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  }\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  Provider.displayName = rootComponentName + 'Provider';\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    function Provider(\n      props: ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    ) {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName][index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    }\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName][index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    Provider.displayName = rootComponentName + 'Provider';\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}></CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n","import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\n/**\n * Listens for when the escape key is down\n */\nfunction useEscapeKeydown(\n  onEscapeKeyDownProp?: (event: KeyboardEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        onEscapeKeyDown(event);\n      }\n    };\n    ownerDocument.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => ownerDocument.removeEventListener('keydown', handleKeyDown, { capture: true });\n  }, [onEscapeKeyDown, ownerDocument]);\n}\n\nexport { useEscapeKeydown };\n","import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n","import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * VisuallyHidden\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'VisuallyHidden';\n\ntype VisuallyHiddenElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface VisuallyHiddenProps extends PrimitiveSpanProps {}\n\nconst VisuallyHidden = React.forwardRef<VisuallyHiddenElement, VisuallyHiddenProps>(\n  (props, forwardedRef) => {\n    return (\n      <Primitive.span\n        {...props}\n        ref={forwardedRef}\n        style={{\n          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n          position: 'absolute',\n          border: 0,\n          width: 1,\n          height: 1,\n          padding: 0,\n          margin: -1,\n          overflow: 'hidden',\n          clip: 'rect(0, 0, 0, 0)',\n          whiteSpace: 'nowrap',\n          wordWrap: 'normal',\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nVisuallyHidden.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = VisuallyHidden;\n\nexport {\n  VisuallyHidden,\n  //\n  Root,\n};\nexport type { VisuallyHiddenProps };\n","/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { composeRefs, useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { Presence } from '@radix-ui/react-presence';\nimport { useId } from '@radix-ui/react-id';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Orientation = 'vertical' | 'horizontal';\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAVIGATION_MENU_NAME = 'NavigationMenu';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  NavigationMenuTriggerElement,\n  { value: string }\n>(NAVIGATION_MENU_NAME);\n\nconst [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] =\n  createCollection<FocusGroupItemElement, {}>(NAVIGATION_MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeNavigationMenu?: Scope };\nconst [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(\n  NAVIGATION_MENU_NAME,\n  [createCollectionScope, createFocusGroupCollectionScope]\n);\n\ntype ContentData = {\n  ref?: React.Ref<ViewportContentMounterElement>;\n} & ViewportContentMounterProps;\n\ntype NavigationMenuContextValue = {\n  isRootMenu: boolean;\n  value: string;\n  previousValue: string;\n  baseId: string;\n  dir: Direction;\n  orientation: Orientation;\n  rootNavigationMenu: NavigationMenuElement | null;\n  indicatorTrack: HTMLDivElement | null;\n  onIndicatorTrackChange(indicatorTrack: HTMLDivElement | null): void;\n  viewport: NavigationMenuViewportElement | null;\n  onViewportChange(viewport: NavigationMenuViewportElement | null): void;\n  onViewportContentChange(contentValue: string, contentData: ContentData): void;\n  onViewportContentRemove(contentValue: string): void;\n  onTriggerEnter(itemValue: string): void;\n  onTriggerLeave(): void;\n  onContentEnter(): void;\n  onContentLeave(): void;\n  onItemSelect(itemValue: string): void;\n  onItemDismiss(): void;\n};\n\nconst [NavigationMenuProviderImpl, useNavigationMenuContext] =\n  createNavigationMenuContext<NavigationMenuContextValue>(NAVIGATION_MENU_NAME);\n\nconst [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext<{\n  items: Map<string, ContentData>;\n}>(NAVIGATION_MENU_NAME);\n\ntype NavigationMenuElement = React.ElementRef<typeof Primitive.nav>;\ntype PrimitiveNavProps = React.ComponentPropsWithoutRef<typeof Primitive.nav>;\ninterface NavigationMenuProps\n  extends Omit<NavigationMenuProviderProps, keyof NavigationMenuProviderPrivateProps>,\n    PrimitiveNavProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  dir?: Direction;\n  orientation?: Orientation;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 200\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n}\n\nconst NavigationMenu = React.forwardRef<NavigationMenuElement, NavigationMenuProps>(\n  (props: ScopedProps<NavigationMenuProps>, forwardedRef) => {\n    const {\n      __scopeNavigationMenu,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      delayDuration = 200,\n      skipDelayDuration = 300,\n      orientation = 'horizontal',\n      dir,\n      ...NavigationMenuProps\n    } = props;\n    const [navigationMenu, setNavigationMenu] = React.useState<NavigationMenuElement | null>(null);\n    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));\n    const direction = useDirection(dir);\n    const openTimerRef = React.useRef(0);\n    const closeTimerRef = React.useRef(0);\n    const skipDelayTimerRef = React.useRef(0);\n    const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: (value) => {\n        const isOpen = value !== '';\n        const hasSkipDelayDuration = skipDelayDuration > 0;\n\n        if (isOpen) {\n          window.clearTimeout(skipDelayTimerRef.current);\n          if (hasSkipDelayDuration) setIsOpenDelayed(false);\n        } else {\n          window.clearTimeout(skipDelayTimerRef.current);\n          skipDelayTimerRef.current = window.setTimeout(\n            () => setIsOpenDelayed(true),\n            skipDelayDuration\n          );\n        }\n\n        onValueChange?.(value);\n      },\n      defaultProp: defaultValue,\n    });\n\n    const startCloseTimer = React.useCallback(() => {\n      window.clearTimeout(closeTimerRef.current);\n      closeTimerRef.current = window.setTimeout(() => setValue(''), 150);\n    }, [setValue]);\n\n    const handleOpen = React.useCallback(\n      (itemValue: string) => {\n        window.clearTimeout(closeTimerRef.current);\n        setValue(itemValue);\n      },\n      [setValue]\n    );\n\n    const handleDelayedOpen = React.useCallback(\n      (itemValue: string) => {\n        const isOpenItem = value === itemValue;\n        if (isOpenItem) {\n          // If the item is already open (e.g. we're transitioning from the content to the trigger)\n          // then we want to clear the close timer immediately.\n          window.clearTimeout(closeTimerRef.current);\n        } else {\n          openTimerRef.current = window.setTimeout(() => {\n            window.clearTimeout(closeTimerRef.current);\n            setValue(itemValue);\n          }, delayDuration);\n        }\n      },\n      [value, setValue, delayDuration]\n    );\n\n    React.useEffect(() => {\n      return () => {\n        window.clearTimeout(openTimerRef.current);\n        window.clearTimeout(closeTimerRef.current);\n        window.clearTimeout(skipDelayTimerRef.current);\n      };\n    }, []);\n\n    return (\n      <NavigationMenuProvider\n        scope={__scopeNavigationMenu}\n        isRootMenu={true}\n        value={value}\n        dir={direction}\n        orientation={orientation}\n        rootNavigationMenu={navigationMenu}\n        onTriggerEnter={(itemValue) => {\n          window.clearTimeout(openTimerRef.current);\n          if (isOpenDelayed) handleDelayedOpen(itemValue);\n          else handleOpen(itemValue);\n        }}\n        onTriggerLeave={() => {\n          window.clearTimeout(openTimerRef.current);\n          startCloseTimer();\n        }}\n        onContentEnter={() => window.clearTimeout(closeTimerRef.current)}\n        onContentLeave={startCloseTimer}\n        onItemSelect={(itemValue) => {\n          setValue((prevValue) => (prevValue === itemValue ? '' : itemValue));\n        }}\n        onItemDismiss={() => setValue('')}\n      >\n        <Primitive.nav\n          aria-label=\"Main\"\n          data-orientation={orientation}\n          dir={direction}\n          {...NavigationMenuProps}\n          ref={composedRef}\n        />\n      </NavigationMenuProvider>\n    );\n  }\n);\n\nNavigationMenu.displayName = NAVIGATION_MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'NavigationMenuSub';\n\ntype NavigationMenuSubElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface NavigationMenuSubProps\n  extends Omit<NavigationMenuProviderProps, keyof NavigationMenuProviderPrivateProps>,\n    PrimitiveDivProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  orientation?: Orientation;\n}\n\nconst NavigationMenuSub = React.forwardRef<NavigationMenuSubElement, NavigationMenuSubProps>(\n  (props: ScopedProps<NavigationMenuSubProps>, forwardedRef) => {\n    const {\n      __scopeNavigationMenu,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = 'horizontal',\n      ...subProps\n    } = props;\n    const context = useNavigationMenuContext(SUB_NAME, __scopeNavigationMenu);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue,\n    });\n\n    return (\n      <NavigationMenuProvider\n        scope={__scopeNavigationMenu}\n        isRootMenu={false}\n        value={value}\n        dir={context.dir}\n        orientation={orientation}\n        rootNavigationMenu={context.rootNavigationMenu}\n        onTriggerEnter={(itemValue) => setValue(itemValue)}\n        onItemSelect={(itemValue) => setValue(itemValue)}\n        onItemDismiss={() => setValue('')}\n      >\n        <Primitive.div data-orientation={orientation} {...subProps} ref={forwardedRef} />\n      </NavigationMenuProvider>\n    );\n  }\n);\n\nNavigationMenuSub.displayName = SUB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface NavigationMenuProviderPrivateProps {\n  isRootMenu: boolean;\n  scope: Scope;\n  children: React.ReactNode;\n  orientation: Orientation;\n  dir: Direction;\n  rootNavigationMenu: NavigationMenuElement | null;\n  value: string;\n  onTriggerEnter(itemValue: string): void;\n  onTriggerLeave?(): void;\n  onContentEnter?(): void;\n  onContentLeave?(): void;\n  onItemSelect(itemValue: string): void;\n  onItemDismiss(): void;\n}\n\ninterface NavigationMenuProviderProps extends NavigationMenuProviderPrivateProps {}\n\nconst NavigationMenuProvider: React.FC<NavigationMenuProviderProps> = (\n  props: ScopedProps<NavigationMenuProviderProps>\n) => {\n  const {\n    scope,\n    isRootMenu,\n    rootNavigationMenu,\n    dir,\n    orientation,\n    children,\n    value,\n    onItemSelect,\n    onItemDismiss,\n    onTriggerEnter,\n    onTriggerLeave,\n    onContentEnter,\n    onContentLeave,\n  } = props;\n  const [viewport, setViewport] = React.useState<NavigationMenuViewportElement | null>(null);\n  const [viewportContent, setViewportContent] = React.useState<Map<string, ContentData>>(new Map());\n  const [indicatorTrack, setIndicatorTrack] = React.useState<HTMLDivElement | null>(null);\n\n  return (\n    <NavigationMenuProviderImpl\n      scope={scope}\n      isRootMenu={isRootMenu}\n      rootNavigationMenu={rootNavigationMenu}\n      value={value}\n      previousValue={usePrevious(value)}\n      baseId={useId()}\n      dir={dir}\n      orientation={orientation}\n      viewport={viewport}\n      onViewportChange={setViewport}\n      indicatorTrack={indicatorTrack}\n      onIndicatorTrackChange={setIndicatorTrack}\n      onTriggerEnter={useCallbackRef(onTriggerEnter)}\n      onTriggerLeave={useCallbackRef(onTriggerLeave)}\n      onContentEnter={useCallbackRef(onContentEnter)}\n      onContentLeave={useCallbackRef(onContentLeave)}\n      onItemSelect={useCallbackRef(onItemSelect)}\n      onItemDismiss={useCallbackRef(onItemDismiss)}\n      onViewportContentChange={React.useCallback((contentValue, contentData) => {\n        setViewportContent((prevContent) => {\n          prevContent.set(contentValue, contentData);\n          return new Map(prevContent);\n        });\n      }, [])}\n      onViewportContentRemove={React.useCallback((contentValue) => {\n        setViewportContent((prevContent) => {\n          if (!prevContent.has(contentValue)) return prevContent;\n          prevContent.delete(contentValue);\n          return new Map(prevContent);\n        });\n      }, [])}\n    >\n      <Collection.Provider scope={scope}>\n        <ViewportContentProvider scope={scope} items={viewportContent}>\n          {children}\n        </ViewportContentProvider>\n      </Collection.Provider>\n    </NavigationMenuProviderImpl>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuList\n * -----------------------------------------------------------------------------------------------*/\n\nconst LIST_NAME = 'NavigationMenuList';\n\ntype NavigationMenuListElement = React.ElementRef<typeof Primitive.ul>;\ntype PrimitiveUnorderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ul>;\ninterface NavigationMenuListProps extends PrimitiveUnorderedListProps {}\n\nconst NavigationMenuList = React.forwardRef<NavigationMenuListElement, NavigationMenuListProps>(\n  (props: ScopedProps<NavigationMenuListProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...listProps } = props;\n    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);\n\n    const list = (\n      <Primitive.ul data-orientation={context.orientation} {...listProps} ref={forwardedRef} />\n    );\n\n    return (\n      <Primitive.div style={{ position: 'relative' }} ref={context.onIndicatorTrackChange}>\n        <Collection.Slot scope={__scopeNavigationMenu}>\n          {context.isRootMenu ? <FocusGroup asChild>{list}</FocusGroup> : list}\n        </Collection.Slot>\n      </Primitive.div>\n    );\n  }\n);\n\nNavigationMenuList.displayName = LIST_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'NavigationMenuItem';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHiddenPrimitive.Root>;\n\ntype NavigationMenuItemContextValue = {\n  value: string;\n  triggerRef: React.RefObject<NavigationMenuTriggerElement>;\n  contentRef: React.RefObject<NavigationMenuContentElement>;\n  focusProxyRef: React.RefObject<FocusProxyElement>;\n  wasEscapeCloseRef: React.MutableRefObject<boolean>;\n  onEntryKeyDown(): void;\n  onFocusProxyEnter(side: 'start' | 'end'): void;\n  onRootContentClose(): void;\n  onContentFocusOutside(): void;\n};\n\nconst [NavigationMenuItemContextProvider, useNavigationMenuItemContext] =\n  createNavigationMenuContext<NavigationMenuItemContextValue>(ITEM_NAME);\n\ntype NavigationMenuItemElement = React.ElementRef<typeof Primitive.li>;\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface NavigationMenuItemProps extends PrimitiveListItemProps {\n  value?: string;\n}\n\nconst NavigationMenuItem = React.forwardRef<NavigationMenuItemElement, NavigationMenuItemProps>(\n  (props: ScopedProps<NavigationMenuItemProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;\n    const autoValue = useId();\n    // We need to provide an initial deterministic value as `useId` will return\n    // empty string on the first render and we don't want to match our internal \"closed\" value.\n    const value = valueProp || autoValue || 'LEGACY_REACT_AUTO_VALUE';\n    const contentRef = React.useRef<NavigationMenuContentElement>(null);\n    const triggerRef = React.useRef<NavigationMenuTriggerElement>(null);\n    const focusProxyRef = React.useRef<FocusProxyElement>(null);\n    const restoreContentTabOrderRef = React.useRef(() => {});\n    const wasEscapeCloseRef = React.useRef(false);\n\n    const handleContentEntry = React.useCallback((side = 'start') => {\n      if (contentRef.current) {\n        restoreContentTabOrderRef.current();\n        const candidates = getTabbableCandidates(contentRef.current);\n        if (candidates.length) focusFirst(side === 'start' ? candidates : candidates.reverse());\n      }\n    }, []);\n\n    const handleContentExit = React.useCallback(() => {\n      if (contentRef.current) {\n        const candidates = getTabbableCandidates(contentRef.current);\n        if (candidates.length) restoreContentTabOrderRef.current = removeFromTabOrder(candidates);\n      }\n    }, []);\n\n    return (\n      <NavigationMenuItemContextProvider\n        scope={__scopeNavigationMenu}\n        value={value}\n        triggerRef={triggerRef}\n        contentRef={contentRef}\n        focusProxyRef={focusProxyRef}\n        wasEscapeCloseRef={wasEscapeCloseRef}\n        onEntryKeyDown={handleContentEntry}\n        onFocusProxyEnter={handleContentEntry}\n        onRootContentClose={handleContentExit}\n        onContentFocusOutside={handleContentExit}\n      >\n        <Primitive.li {...itemProps} ref={forwardedRef} />\n      </NavigationMenuItemContextProvider>\n    );\n  }\n);\n\nNavigationMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'NavigationMenuTrigger';\n\ntype NavigationMenuTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface NavigationMenuTriggerProps extends PrimitiveButtonProps {}\n\nconst NavigationMenuTrigger = React.forwardRef<\n  NavigationMenuTriggerElement,\n  NavigationMenuTriggerProps\n>((props: ScopedProps<NavigationMenuTriggerProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;\n  const context = useNavigationMenuContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const ref = React.useRef<NavigationMenuTriggerElement>(null);\n  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, itemContext.value);\n  const contentId = makeContentId(context.baseId, itemContext.value);\n  const hasPointerMoveOpenedRef = React.useRef(false);\n  const wasClickCloseRef = React.useRef(false);\n  const open = itemContext.value === context.value;\n\n  return (\n    <>\n      <Collection.ItemSlot scope={__scopeNavigationMenu} value={itemContext.value}>\n        <FocusGroupItem asChild>\n          <Primitive.button\n            id={triggerId}\n            disabled={disabled}\n            data-disabled={disabled ? '' : undefined}\n            data-state={getOpenState(open)}\n            aria-expanded={open}\n            aria-controls={contentId}\n            {...triggerProps}\n            ref={composedRefs}\n            onPointerEnter={composeEventHandlers(props.onPointerEnter, () => {\n              wasClickCloseRef.current = false;\n              itemContext.wasEscapeCloseRef.current = false;\n            })}\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse(() => {\n                if (\n                  disabled ||\n                  wasClickCloseRef.current ||\n                  itemContext.wasEscapeCloseRef.current ||\n                  hasPointerMoveOpenedRef.current\n                )\n                  return;\n                context.onTriggerEnter(itemContext.value);\n                hasPointerMoveOpenedRef.current = true;\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse(() => {\n                if (disabled) return;\n                context.onTriggerLeave();\n                hasPointerMoveOpenedRef.current = false;\n              })\n            )}\n            onClick={composeEventHandlers(props.onClick, () => {\n              context.onItemSelect(itemContext.value);\n              wasClickCloseRef.current = open;\n            })}\n            onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n              const verticalEntryKey = context.dir === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n              const entryKey = { horizontal: 'ArrowDown', vertical: verticalEntryKey }[\n                context.orientation\n              ];\n              if (open && event.key === entryKey) {\n                itemContext.onEntryKeyDown();\n                // Prevent FocusGroupItem from handling the event\n                event.preventDefault();\n              }\n            })}\n          />\n        </FocusGroupItem>\n      </Collection.ItemSlot>\n\n      {/* Proxy tab order between trigger and content */}\n      {open && (\n        <>\n          <VisuallyHiddenPrimitive.Root\n            aria-hidden\n            tabIndex={0}\n            ref={itemContext.focusProxyRef}\n            onFocus={(event) => {\n              const content = itemContext.contentRef.current;\n              const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n              const wasTriggerFocused = prevFocusedElement === ref.current;\n              const wasFocusFromContent = content?.contains(prevFocusedElement);\n\n              if (wasTriggerFocused || !wasFocusFromContent) {\n                itemContext.onFocusProxyEnter(wasTriggerFocused ? 'start' : 'end');\n              }\n            }}\n          />\n\n          {/* Restructure a11y tree to make content accessible to screen reader when using the viewport */}\n          {context.viewport && <span aria-owns={contentId} />}\n        </>\n      )}\n    </>\n  );\n});\n\nNavigationMenuTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuLink\n * -----------------------------------------------------------------------------------------------*/\n\nconst LINK_NAME = 'NavigationMenuLink';\nconst LINK_SELECT = 'navigationMenu.linkSelect';\n\ntype NavigationMenuLinkElement = React.ElementRef<typeof Primitive.a>;\ntype PrimitiveLinkProps = React.ComponentPropsWithoutRef<typeof Primitive.a>;\ninterface NavigationMenuLinkProps extends Omit<PrimitiveLinkProps, 'onSelect'> {\n  active?: boolean;\n  onSelect?: (event: Event) => void;\n}\n\nconst NavigationMenuLink = React.forwardRef<NavigationMenuLinkElement, NavigationMenuLinkProps>(\n  (props: ScopedProps<NavigationMenuLinkProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, active, onSelect, ...linkProps } = props;\n\n    return (\n      <FocusGroupItem asChild>\n        <Primitive.a\n          data-active={active ? '' : undefined}\n          aria-current={active ? 'page' : undefined}\n          {...linkProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(\n            props.onClick,\n            (event) => {\n              const target = event.target as HTMLElement;\n              const linkSelectEvent = new CustomEvent(LINK_SELECT, {\n                bubbles: true,\n                cancelable: true,\n              });\n              target.addEventListener(LINK_SELECT, (event) => onSelect?.(event), { once: true });\n              dispatchDiscreteCustomEvent(target, linkSelectEvent);\n\n              if (!linkSelectEvent.defaultPrevented && !event.metaKey) {\n                const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {\n                  bubbles: true,\n                  cancelable: true,\n                });\n                dispatchDiscreteCustomEvent(target, rootContentDismissEvent);\n              }\n            },\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </FocusGroupItem>\n    );\n  }\n);\n\nNavigationMenuLink.displayName = LINK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'NavigationMenuIndicator';\n\ntype NavigationMenuIndicatorElement = NavigationMenuIndicatorImplElement;\ninterface NavigationMenuIndicatorProps extends NavigationMenuIndicatorImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuIndicator = React.forwardRef<\n  NavigationMenuIndicatorElement,\n  NavigationMenuIndicatorProps\n>((props: ScopedProps<NavigationMenuIndicatorProps>, forwardedRef) => {\n  const { forceMount, ...indicatorProps } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, props.__scopeNavigationMenu);\n  const isVisible = Boolean(context.value);\n\n  return context.indicatorTrack\n    ? ReactDOM.createPortal(\n        <Presence present={forceMount || isVisible}>\n          <NavigationMenuIndicatorImpl {...indicatorProps} ref={forwardedRef} />\n        </Presence>,\n        context.indicatorTrack\n      )\n    : null;\n});\n\nNavigationMenuIndicator.displayName = INDICATOR_NAME;\n\ntype NavigationMenuIndicatorImplElement = React.ElementRef<typeof Primitive.div>;\ninterface NavigationMenuIndicatorImplProps extends PrimitiveDivProps {}\n\nconst NavigationMenuIndicatorImpl = React.forwardRef<\n  NavigationMenuIndicatorImplElement,\n  NavigationMenuIndicatorImplProps\n>((props: ScopedProps<NavigationMenuIndicatorImplProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, ...indicatorProps } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, __scopeNavigationMenu);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const [activeTrigger, setActiveTrigger] = React.useState<NavigationMenuTriggerElement | null>(\n    null\n  );\n  const [position, setPosition] = React.useState<{ size: number; offset: number } | null>(null);\n  const isHorizontal = context.orientation === 'horizontal';\n  const isVisible = Boolean(context.value);\n\n  React.useEffect(() => {\n    const items = getItems();\n    const triggerNode = items.find((item) => item.value === context.value)?.ref.current;\n    if (triggerNode) setActiveTrigger(triggerNode);\n  }, [getItems, context.value]);\n\n  /**\n   * Update position when the indicator or parent track size changes\n   */\n  const handlePositionChange = () => {\n    if (activeTrigger) {\n      setPosition({\n        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,\n        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop,\n      });\n    }\n  };\n  useResizeObserver(activeTrigger, handlePositionChange);\n  useResizeObserver(context.indicatorTrack, handlePositionChange);\n\n  // We need to wait for the indicator position to be available before rendering to\n  // snap immediately into position rather than transitioning from initial\n  return position ? (\n    <Primitive.div\n      aria-hidden\n      data-state={isVisible ? 'visible' : 'hidden'}\n      data-orientation={context.orientation}\n      {...indicatorProps}\n      ref={forwardedRef}\n      style={{\n        position: 'absolute',\n        ...(isHorizontal\n          ? {\n              left: 0,\n              width: position.size + 'px',\n              transform: `translateX(${position.offset}px)`,\n            }\n          : {\n              top: 0,\n              height: position.size + 'px',\n              transform: `translateY(${position.offset}px)`,\n            }),\n        ...indicatorProps.style,\n      }}\n    />\n  ) : null;\n});\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'NavigationMenuContent';\n\ntype NavigationMenuContentElement = NavigationMenuContentImplElement;\ninterface NavigationMenuContentProps\n  extends Omit<NavigationMenuContentImplProps, keyof NavigationMenuContentImplPrivateProps> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuContent = React.forwardRef<\n  NavigationMenuContentElement,\n  NavigationMenuContentProps\n>((props: ScopedProps<NavigationMenuContentProps>, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);\n  const open = itemContext.value === context.value;\n\n  const commonProps = {\n    value: itemContext.value,\n    triggerRef: itemContext.triggerRef,\n    focusProxyRef: itemContext.focusProxyRef,\n    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,\n    onContentFocusOutside: itemContext.onContentFocusOutside,\n    onRootContentClose: itemContext.onRootContentClose,\n    ...contentProps,\n  };\n\n  return !context.viewport ? (\n    <Presence present={forceMount || open}>\n      <NavigationMenuContentImpl\n        data-state={getOpenState(open)}\n        {...commonProps}\n        ref={composedRefs}\n        onPointerEnter={composeEventHandlers(props.onPointerEnter, context.onContentEnter)}\n        onPointerLeave={composeEventHandlers(\n          props.onPointerLeave,\n          whenMouse(context.onContentLeave)\n        )}\n        style={{\n          // Prevent interaction when animating out\n          pointerEvents: !open && context.isRootMenu ? 'none' : undefined,\n          ...commonProps.style,\n        }}\n      />\n    </Presence>\n  ) : (\n    <ViewportContentMounter forceMount={forceMount} {...commonProps} ref={composedRefs} />\n  );\n});\n\nNavigationMenuContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ViewportContentMounterElement = NavigationMenuContentImplElement;\ninterface ViewportContentMounterProps extends NavigationMenuContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst ViewportContentMounter = React.forwardRef<\n  ViewportContentMounterElement,\n  ViewportContentMounterProps\n>((props: ScopedProps<ViewportContentMounterProps>, forwardedRef) => {\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const { onViewportContentChange, onViewportContentRemove } = context;\n\n  useLayoutEffect(() => {\n    onViewportContentChange(props.value, {\n      ref: forwardedRef,\n      ...props,\n    });\n  }, [props, forwardedRef, onViewportContentChange]);\n\n  useLayoutEffect(() => {\n    return () => onViewportContentRemove(props.value);\n  }, [props.value, onViewportContentRemove]);\n\n  // Content is proxied into the viewport\n  return null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';\n\ntype MotionAttribute = 'to-start' | 'to-end' | 'from-start' | 'from-end';\ntype NavigationMenuContentImplElement = React.ElementRef<typeof DismissableLayer>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\n\ninterface NavigationMenuContentImplPrivateProps {\n  value: string;\n  triggerRef: React.RefObject<NavigationMenuTriggerElement>;\n  focusProxyRef: React.RefObject<FocusProxyElement>;\n  wasEscapeCloseRef: React.MutableRefObject<boolean>;\n  onContentFocusOutside(): void;\n  onRootContentClose(): void;\n}\ninterface NavigationMenuContentImplProps\n  extends Omit<DismissableLayerProps, 'onDismiss' | 'disableOutsidePointerEvents'>,\n    NavigationMenuContentImplPrivateProps {}\n\nconst NavigationMenuContentImpl = React.forwardRef<\n  NavigationMenuContentImplElement,\n  NavigationMenuContentImplProps\n>((props: ScopedProps<NavigationMenuContentImplProps>, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value,\n    triggerRef,\n    focusProxyRef,\n    wasEscapeCloseRef,\n    onRootContentClose,\n    onContentFocusOutside,\n    ...contentProps\n  } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, __scopeNavigationMenu);\n  const ref = React.useRef<NavigationMenuContentImplElement>(null);\n  const composedRefs = useComposedRefs(ref, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, value);\n  const contentId = makeContentId(context.baseId, value);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const prevMotionAttributeRef = React.useRef<MotionAttribute | null>(null);\n\n  const { onItemDismiss } = context;\n\n  React.useEffect(() => {\n    const content = ref.current;\n\n    // Bubble dismiss to the root content node and focus its trigger\n    if (context.isRootMenu && content) {\n      const handleClose = () => {\n        onItemDismiss();\n        onRootContentClose();\n        if (content.contains(document.activeElement)) triggerRef.current?.focus();\n      };\n      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);\n      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);\n    }\n  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);\n\n  const motionAttribute = React.useMemo(() => {\n    const items = getItems();\n    const values = items.map((item) => item.value);\n    if (context.dir === 'rtl') values.reverse();\n    const index = values.indexOf(context.value);\n    const prevIndex = values.indexOf(context.previousValue);\n    const isSelected = value === context.value;\n    const wasSelected = prevIndex === values.indexOf(value);\n\n    // We only want to update selected and the last selected content\n    // this avoids animations being interrupted outside of that range\n    if (!isSelected && !wasSelected) return prevMotionAttributeRef.current;\n\n    const attribute = (() => {\n      // Don't provide a direction on the initial open\n      if (index !== prevIndex) {\n        // If we're moving to this item from another\n        if (isSelected && prevIndex !== -1) return index > prevIndex ? 'from-end' : 'from-start';\n        // If we're leaving this item for another\n        if (wasSelected && index !== -1) return index > prevIndex ? 'to-start' : 'to-end';\n      }\n      // Otherwise we're entering from closed or leaving the list\n      // entirely and should not animate in any direction\n      return null;\n    })();\n\n    prevMotionAttributeRef.current = attribute;\n    return attribute;\n  }, [context.previousValue, context.value, context.dir, getItems, value]);\n\n  return (\n    <FocusGroup asChild>\n      <DismissableLayer\n        id={contentId}\n        aria-labelledby={triggerId}\n        data-motion={motionAttribute}\n        data-orientation={context.orientation}\n        {...contentProps}\n        ref={composedRefs}\n        disableOutsidePointerEvents={false}\n        onDismiss={() => {\n          const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {\n            bubbles: true,\n            cancelable: true,\n          });\n          ref.current?.dispatchEvent(rootContentDismissEvent);\n        }}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          onContentFocusOutside();\n          const target = event.target as HTMLElement;\n          // Only dismiss content when focus moves outside of the menu\n          if (context.rootNavigationMenu?.contains(target)) event.preventDefault();\n        })}\n        onPointerDownOutside={composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const target = event.target as HTMLElement;\n          const isTrigger = getItems().some((item) => item.ref.current?.contains(target));\n          const isRootViewport = context.isRootMenu && context.viewport?.contains(target);\n          if (isTrigger || isRootViewport || !context.isRootMenu) event.preventDefault();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n          if (isTabKey) {\n            const candidates = getTabbableCandidates(event.currentTarget);\n            const focusedElement = document.activeElement;\n            const index = candidates.findIndex((candidate) => candidate === focusedElement);\n            const isMovingBackwards = event.shiftKey;\n            const nextCandidates = isMovingBackwards\n              ? candidates.slice(0, index).reverse()\n              : candidates.slice(index + 1, candidates.length);\n\n            if (focusFirst(nextCandidates)) {\n              // prevent browser tab keydown because we've handled focus\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges\n              // so focus the proxy and let browser handle\n              // tab/shift+tab keypress on the proxy instead\n              focusProxyRef.current?.focus();\n            }\n          }\n        })}\n        onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n          // prevent the dropdown from reopening\n          // after the escape key has been pressed\n          wasEscapeCloseRef.current = true;\n        })}\n      />\n    </FocusGroup>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'NavigationMenuViewport';\n\ntype NavigationMenuViewportElement = NavigationMenuViewportImplElement;\ninterface NavigationMenuViewportProps\n  extends Omit<NavigationMenuViewportImplProps, 'activeContentValue'> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuViewport = React.forwardRef<\n  NavigationMenuViewportElement,\n  NavigationMenuViewportProps\n>((props: ScopedProps<NavigationMenuViewportProps>, forwardedRef) => {\n  const { forceMount, ...viewportProps } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, props.__scopeNavigationMenu);\n  const open = Boolean(context.value);\n\n  return (\n    <Presence present={forceMount || open}>\n      <NavigationMenuViewportImpl {...viewportProps} ref={forwardedRef} />\n    </Presence>\n  );\n});\n\nNavigationMenuViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype NavigationMenuViewportImplElement = React.ElementRef<typeof Primitive.div>;\ninterface NavigationMenuViewportImplProps extends PrimitiveDivProps {}\n\nconst NavigationMenuViewportImpl = React.forwardRef<\n  NavigationMenuViewportImplElement,\n  NavigationMenuViewportImplProps\n>((props: ScopedProps<NavigationMenuViewportImplProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, __scopeNavigationMenu);\n  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);\n  const viewportContentContext = useViewportContentContext(\n    CONTENT_NAME,\n    props.__scopeNavigationMenu\n  );\n  const [size, setSize] = React.useState<{ width: number; height: number } | null>(null);\n  const [content, setContent] = React.useState<NavigationMenuContentElement | null>(null);\n  const viewportWidth = size ? size?.width + 'px' : undefined;\n  const viewportHeight = size ? size?.height + 'px' : undefined;\n  const open = Boolean(context.value);\n  // We persist the last active content value as the viewport may be animating out\n  // and we want the content to remain mounted for the lifecycle of the viewport.\n  const activeContentValue = open ? context.value : context.previousValue;\n\n  /**\n   * Update viewport size to match the active content node.\n   * We prefer offset dimensions over `getBoundingClientRect` as the latter respects CSS transform.\n   * For example, if content animates in from `scale(0.5)` the dimensions would be anything\n   * from `0.5` to `1` of the intended size.\n   */\n  const handleSizeChange = () => {\n    if (content) setSize({ width: content.offsetWidth, height: content.offsetHeight });\n  };\n  useResizeObserver(content, handleSizeChange);\n\n  return (\n    <Primitive.div\n      data-state={getOpenState(open)}\n      data-orientation={context.orientation}\n      {...viewportImplProps}\n      ref={composedRefs}\n      style={{\n        // Prevent interaction when animating out\n        pointerEvents: !open && context.isRootMenu ? 'none' : undefined,\n        ['--radix-navigation-menu-viewport-width' as any]: viewportWidth,\n        ['--radix-navigation-menu-viewport-height' as any]: viewportHeight,\n        ...viewportImplProps.style,\n      }}\n      onPointerEnter={composeEventHandlers(props.onPointerEnter, context.onContentEnter)}\n      onPointerLeave={composeEventHandlers(props.onPointerLeave, whenMouse(context.onContentLeave))}\n    >\n      {Array.from(viewportContentContext.items).map(([value, { ref, forceMount, ...props }]) => {\n        const isActive = activeContentValue === value;\n        return (\n          <Presence key={value} present={forceMount || isActive}>\n            <NavigationMenuContentImpl\n              {...props}\n              ref={composeRefs(ref, (node) => {\n                // We only want to update the stored node when another is available\n                // as we need to smoothly transition between them.\n                if (isActive && node) setContent(node);\n              })}\n            />\n          </Presence>\n        );\n      })}\n    </Primitive.div>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_GROUP_NAME = 'FocusGroup';\n\ntype FocusGroupElement = React.ElementRef<typeof Primitive.div>;\ninterface FocusGroupProps extends PrimitiveDivProps {}\n\nconst FocusGroup = React.forwardRef<FocusGroupElement, FocusGroupProps>(\n  (props: ScopedProps<FocusGroupProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...groupProps } = props;\n    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);\n\n    return (\n      <FocusGroupCollection.Provider scope={__scopeNavigationMenu}>\n        <FocusGroupCollection.Slot scope={__scopeNavigationMenu}>\n          <Primitive.div dir={context.dir} {...groupProps} ref={forwardedRef} />\n        </FocusGroupCollection.Slot>\n      </FocusGroupCollection.Provider>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_KEYS = ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'];\nconst FOCUS_GROUP_ITEM_NAME = 'FocusGroupItem';\n\ntype FocusGroupItemElement = React.ElementRef<typeof Primitive.button>;\ninterface FocusGroupItemProps extends PrimitiveButtonProps {}\n\nconst FocusGroupItem = React.forwardRef<FocusGroupItemElement, FocusGroupItemProps>(\n  (props: ScopedProps<FocusGroupItemProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...groupProps } = props;\n    const getItems = useFocusGroupCollection(__scopeNavigationMenu);\n    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);\n\n    return (\n      <FocusGroupCollection.ItemSlot scope={__scopeNavigationMenu}>\n        <Primitive.button\n          {...groupProps}\n          ref={forwardedRef}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isFocusNavigationKey = ['Home', 'End', ...ARROW_KEYS].includes(event.key);\n            if (isFocusNavigationKey) {\n              let candidateNodes = getItems().map((item) => item.ref.current!);\n              const prevItemKey = context.dir === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n              const prevKeys = [prevItemKey, 'ArrowUp', 'End'];\n              if (prevKeys.includes(event.key)) candidateNodes.reverse();\n              if (ARROW_KEYS.includes(event.key)) {\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = candidateNodes.slice(currentIndex + 1);\n              }\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n\n              // Prevent page scroll while navigating\n              event.preventDefault();\n            }\n          })}\n        />\n      </FocusGroupCollection.ItemSlot>\n    );\n  }\n);\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nfunction removeFromTabOrder(candidates: HTMLElement[]) {\n  candidates.forEach((candidate) => {\n    candidate.dataset.tabindex = candidate.getAttribute('tabindex') || '';\n    candidate.setAttribute('tabindex', '-1');\n  });\n  return () => {\n    candidates.forEach((candidate) => {\n      const prevTabIndex = candidate.dataset.tabindex as string;\n      candidate.setAttribute('tabindex', prevTabIndex);\n    });\n  };\n}\n\nfunction useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n    if (element) {\n      /**\n       * Resize Observer will throw an often benign error that says `ResizeObserver loop\n       * completed with undelivered notifications`. This means that ResizeObserver was not\n       * able to deliver all observations within a single animation frame, so we use\n       * `requestAnimationFrame` to ensure we don't deliver unnecessary observations.\n       * Further reading: https://github.com/WICG/resize-observer/issues/38\n       */\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`;\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = NavigationMenu;\nconst Sub = NavigationMenuSub;\nconst List = NavigationMenuList;\nconst Item = NavigationMenuItem;\nconst Trigger = NavigationMenuTrigger;\nconst Link = NavigationMenuLink;\nconst Indicator = NavigationMenuIndicator;\nconst Content = NavigationMenuContent;\nconst Viewport = NavigationMenuViewport;\n\nexport {\n  createNavigationMenuScope,\n  //\n  NavigationMenu,\n  NavigationMenuSub,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuContent,\n  NavigationMenuViewport,\n  //\n  Root,\n  Sub,\n  List,\n  Item,\n  Trigger,\n  Link,\n  Indicator,\n  Content,\n  Viewport,\n};\nexport type {\n  NavigationMenuProps,\n  NavigationMenuSubProps,\n  NavigationMenuListProps,\n  NavigationMenuItemProps,\n  NavigationMenuTriggerProps,\n  NavigationMenuLinkProps,\n  NavigationMenuIndicatorProps,\n  NavigationMenuContentProps,\n  NavigationMenuViewportProps,\n};\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Slot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not nessesary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click \n * target.dispatchEvent(new Event(click))\n *\n * dispatching a custom type within a non-discrete event \n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(customType))}\n *\n * dispatching a custom type within a `discrete` event \n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(customType))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children as React.ReactNode;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props.children as React.ReactNode)\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    const childrenRef = getElementRef(children);\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      // @ts-ignore\n      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef,\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n","import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nexport { useCallbackRef };\n","import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = Boolean(globalThis?.document) ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","import { EmblaPluginType } from 'embla-carousel'\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isRecord(\n  subject: unknown\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || Array.isArray(subject)\n}\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areOptionsEqual(\n  optionsA: Record<string, unknown>,\n  optionsB: Record<string, unknown>\n): boolean {\n  const optionsAKeys = Object.keys(optionsA)\n  const optionsBKeys = Object.keys(optionsB)\n\n  if (optionsAKeys.length !== optionsBKeys.length) return false\n\n  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}))\n  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}))\n\n  if (breakpointsA !== breakpointsB) return false\n\n  return optionsAKeys.every((key) => {\n    const valueA = optionsA[key]\n    const valueB = optionsB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return areOptionsEqual(valueA, valueB)\n  })\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[]\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[]\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areOptionsEqual(optionA, optionB)\n  })\n}\n","import { PointerEventType } from './DragTracker'\n\nexport type WindowType = Window & typeof globalThis\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isString(subject: unknown): subject is string {\n  return typeof subject === 'string'\n}\n\nexport function isBoolean(subject: unknown): subject is boolean {\n  return typeof subject === 'boolean'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return Math.sign(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToTwoDecimals(num: number): number {\n  return Math.round(num * 100) / 100\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function arrayIsLastIndex<Type>(array: Type[], index: number): boolean {\n  return index === arrayLastIndex(array)\n}\n\nexport function arrayFromNumber(n: number, startAt: number = 0): number[] {\n  return Array.from(Array(n), (_, i) => startAt + i)\n}\n\nexport function objectKeys<Type extends object>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function isMouseEvent(\n  evt: PointerEventType,\n  ownerWindow: WindowType\n): evt is MouseEvent {\n  return (\n    typeof ownerWindow.MouseEvent !== 'undefined' &&\n    evt instanceof ownerWindow.MouseEvent\n  )\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType\n  ) => EventStoreType\n  clear: () => void\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true }\n  ): EventStoreType {\n    let removeListener: EventRemoverType\n\n    if ('addEventListener' in node) {\n      node.addEventListener(type, handler, options)\n      removeListener = () => node.removeEventListener(type, handler, options)\n    } else {\n      const legacyMediaQueryList = <MediaQueryList>node\n      legacyMediaQueryList.addListener(handler)\n      removeListener = () => legacyMediaQueryList.removeListener(handler)\n    }\n\n    listeners.push(removeListener)\n    return self\n  }\n\n  function clear(): void {\n    listeners = listeners.filter((remove) => remove())\n  }\n\n  const self: EventStoreType = {\n    add,\n    clear\n  }\n  return self\n}\n","import { EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { WindowType } from './utils'\n\nexport type AnimationsUpdateType = (engine: EngineType) => void\nexport type AnimationsRenderType = (engine: EngineType, alpha: number) => void\n\nexport type AnimationsType = {\n  init: () => void\n  destroy: () => void\n  start: () => void\n  stop: () => void\n  update: () => void\n  render: (alpha: number) => void\n}\n\nexport function Animations(\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  update: () => void,\n  render: (alpha: number) => void\n): AnimationsType {\n  const documentVisibleHandler = EventStore()\n  const fixedTimeStep = 1000 / 60\n\n  let lastTimeStamp: number | null = null\n  let accumulatedTime = 0\n  let animationId = 0\n\n  function init(): void {\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.hidden) reset()\n    })\n  }\n\n  function destroy(): void {\n    stop()\n    documentVisibleHandler.clear()\n  }\n\n  function animate(timeStamp: DOMHighResTimeStamp): void {\n    if (!animationId) return\n    if (!lastTimeStamp) lastTimeStamp = timeStamp\n\n    const timeElapsed = timeStamp - lastTimeStamp\n    lastTimeStamp = timeStamp\n    accumulatedTime += timeElapsed\n\n    while (accumulatedTime >= fixedTimeStep) {\n      update()\n      accumulatedTime -= fixedTimeStep\n    }\n\n    const alpha = accumulatedTime / fixedTimeStep\n    render(alpha)\n\n    if (animationId) {\n      animationId = ownerWindow.requestAnimationFrame(animate)\n    }\n  }\n\n  function start(): void {\n    if (animationId) return\n    animationId = ownerWindow.requestAnimationFrame(animate)\n  }\n\n  function stop(): void {\n    ownerWindow.cancelAnimationFrame(animationId)\n    lastTimeStamp = null\n    accumulatedTime = 0\n    animationId = 0\n  }\n\n  function reset(): void {\n    lastTimeStamp = null\n    accumulatedTime = 0\n  }\n\n  const self: AnimationsType = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number = 0, max: number = 0): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean\n): CounterType {\n  const { constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return clone().set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    get,\n    set,\n    add,\n    clone\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1DType } from './Vector1d'\nimport { PercentOfViewType } from './PercentOfView'\nimport { Limit } from './Limit'\nimport {\n  deltaAbs,\n  factorAbs,\n  isBoolean,\n  isMouseEvent,\n  mathAbs,\n  mathSign,\n  WindowType\n} from './utils'\n\ntype DragHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: PointerEventType\n) => boolean | void\n\nexport type DragHandlerOptionType = boolean | DragHandlerCallbackType\n\nexport type DragHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n  pointerDown: () => boolean\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  rootNode: HTMLElement,\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationsType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  dragFree: boolean,\n  dragThreshold: number,\n  skipSnaps: boolean,\n  baseFriction: number,\n  watchDrag: DragHandlerOptionType\n): DragHandlerType {\n  const { cross: crossAxis, direction } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const initEvents = EventStore()\n  const dragEvents = EventStore()\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20))\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 43 : 25\n\n  let isMoving = false\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchDrag) return\n\n    function downIfAllowed(evt: PointerEventType): void {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt)\n    }\n\n    const node = rootNode\n    initEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', () => undefined, nonPassiveEvent)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', downIfAllowed)\n      .add(node, 'mousedown', downIfAllowed)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function destroy(): void {\n    initEvents.clear()\n    dragEvents.clear()\n  }\n\n  function addDragEvents(): void {\n    const node = isMouse ? ownerDocument : rootNode\n    dragEvents\n      .add(node, 'touchmove', move, nonPassiveEvent)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const nodeName = node.nodeName || ''\n    return focusNodes.includes(nodeName)\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.add(mathSign(force) * -1)\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow)\n    isMouse = isMouseEvt\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving\n    isMoving = deltaAbs(target.get(), location.get()) >= 2\n\n    if (isMouseEvt && evt.button !== 0) return\n    if (isFocusNode(evt.target as Element)) return\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    scrollBody.useFriction(0).useDuration(0)\n    target.set(location)\n    addDragEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n  }\n\n  function move(evt: PointerEventType): void {\n    const isTouchEvt = !isMouseEvent(evt, ownerWindow)\n    if (isTouchEvt && evt.touches.length >= 2) return up(evt)\n\n    const lastScroll = dragTracker.readPoint(evt)\n    const lastCross = dragTracker.readPoint(evt, crossAxis)\n    const diffScroll = deltaAbs(lastScroll, startScroll)\n    const diffCross = deltaAbs(lastCross, startCross)\n\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (diffScroll > dragThreshold) preventClick = true\n\n    scrollBody.useFriction(0.3).useDuration(0.75)\n    animation.start()\n    target.add(direction(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const speed = baseSpeed - 10 * forceFactor\n    const friction = baseFriction + forceFactor / 50\n\n    preventScroll = false\n    pointerIsDown = false\n    dragEvents.clear()\n    scrollBody.useDuration(speed).useFriction(friction)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n      preventClick = false\n    }\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    init,\n    destroy,\n    pointerDown\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { isMouseEvent, mathAbs, WindowType } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  ownerWindow: WindowType\n): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { NodeRectsType } from './NodeRects'\nimport { isBoolean, mathAbs, WindowType } from './utils'\n\ntype ResizeHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  entries: ResizeObserverEntry[]\n) => boolean | void\n\nexport type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType\n\nexport type ResizeHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function ResizeHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  ownerWindow: WindowType,\n  slides: HTMLElement[],\n  axis: AxisType,\n  watchResize: ResizeHandlerOptionType,\n  nodeRects: NodeRectsType\n): ResizeHandlerType {\n  const observeNodes = [container].concat(slides)\n  let resizeObserver: ResizeObserver\n  let containerSize: number\n  let slideSizes: number[] = []\n  let destroyed = false\n\n  function readSize(node: HTMLElement): number {\n    return axis.measureSize(nodeRects.measure(node))\n  }\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchResize) return\n\n    containerSize = readSize(container)\n    slideSizes = slides.map(readSize)\n\n    function defaultCallback(entries: ResizeObserverEntry[]): void {\n      for (const entry of entries) {\n        if (destroyed) return\n\n        const isContainer = entry.target === container\n        const slideIndex = slides.indexOf(<HTMLElement>entry.target)\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex]\n        const newSize = readSize(isContainer ? container : slides[slideIndex])\n        const diffSize = mathAbs(newSize - lastSize)\n\n        if (diffSize >= 0.5) {\n          emblaApi.reInit()\n          eventHandler.emit('resize')\n\n          break\n        }\n      }\n    }\n\n    resizeObserver = new ResizeObserver((entries) => {\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries)\n      }\n    })\n\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach((node) => resizeObserver.observe(node))\n    })\n  }\n\n  function destroy(): void {\n    destroyed = true\n    if (resizeObserver) resizeObserver.disconnect()\n  }\n\n  const self: ResizeHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  shouldConstrain: () => boolean\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const frictionLimit = Limit(0.1, 0.99)\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useDuration(25).useBaseFriction()\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[]\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { arrayLast, mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((snap, index) => ({ diff: shortcut(snap - distance, 0), index }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return target\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    if (matchingTargets.length) return minDistance(matchingTargets)\n    return arrayLast(targets) - contentSize\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStoreType } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollToType } from './ScrollTo'\nimport { SlideRegistryType } from './SlideRegistry'\nimport { isBoolean, isNumber } from './utils'\n\ntype FocusHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: FocusEvent\n) => boolean | void\n\nexport type FocusHandlerOptionType = boolean | FocusHandlerCallbackType\n\nexport type SlideFocusType = {\n  init: (emblaApi: EmblaCarouselType) => void\n}\n\nexport function SlideFocus(\n  root: HTMLElement,\n  slides: HTMLElement[],\n  slideRegistry: SlideRegistryType['slideRegistry'],\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  eventStore: EventStoreType,\n  eventHandler: EventHandlerType,\n  watchFocus: FocusHandlerOptionType\n): SlideFocusType {\n  const focusListenerOptions = { passive: true, capture: true }\n  let lastTabPressTime = 0\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchFocus) return\n\n    function defaultCallback(index: number): void {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n\n      if (diffTime > 10) return\n\n      eventHandler.emit('slideFocusStart')\n      root.scrollLeft = 0\n\n      const group = slideRegistry.findIndex((group) => group.includes(index))\n\n      if (!isNumber(group)) return\n\n      scrollBody.useDuration(0)\n      scrollTo.index(group, 0)\n\n      eventHandler.emit('slideFocus')\n    }\n\n    eventStore.add(document, 'keydown', registerTabPress, false)\n\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(\n        slide,\n        'focus',\n        (evt: FocusEvent) => {\n          if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n            defaultCallback(slideIndex)\n          }\n        },\n        focusListenerOptions\n      )\n    })\n  }\n\n  function registerTabPress(event: KeyboardEvent): void {\n    if (event.code === 'Tab') lastTabPressTime = new Date().getTime()\n  }\n\n  const self: SlideFocusType = {\n    init\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (n: Vector1DType | number) => void\n  add: (n: Vector1DType | number) => void\n  subtract: (n: Vector1DType | number) => void\n}\n\nexport function Vector1D(initialValue: number): Vector1DType {\n  let value = initialValue\n\n  function get(): number {\n    return value\n  }\n\n  function set(n: Vector1DType | number): void {\n    value = normalizeInput(n)\n  }\n\n  function add(n: Vector1DType | number): void {\n    value += normalizeInput(n)\n  }\n\n  function subtract(n: Vector1DType | number): void {\n    value -= normalizeInput(n)\n  }\n\n  function normalizeInput(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    get,\n    set,\n    add,\n    subtract\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { roundToTwoDecimals } from './utils'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (target: number) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  container: HTMLElement\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let previousTarget: number | null = null\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: number): void {\n    if (disabled) return\n\n    const newTarget = roundToTwoDecimals(axis.direction(target))\n    if (newTarget === previousTarget) return\n\n    containerStyle.transform = translate(newTarget)\n    previousTarget = newTarget\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\n\ntype SlideBoundType = {\n  start: number\n  end: number\n}\n\ntype LoopPointType = {\n  loopPoint: number\n  index: number\n  translate: TranslateType\n  slideLocation: Vector1DType\n  target: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  slideSizesWithGaps: number[],\n  snaps: number[],\n  scrollSnaps: number[],\n  location: Vector1DType,\n  slides: HTMLElement[]\n): SlideLooperType {\n  const roundingSafety = 0.5\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findSlideBounds(offset: number): SlideBoundType[] {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }))\n  }\n\n  function findLoopPoints(\n    indexes: number[],\n    offset: number,\n    isEndEdge: boolean\n  ): LoopPointType[] {\n    const slideBounds = findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize\n      const altered = isEndEdge ? contentSize : 0\n      const boundEdge = isEndEdge ? 'end' : 'start'\n      const loopPoint = slideBounds[index][boundEdge]\n\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, slides[index]),\n        target: () => (location.get() > loopPoint ? initial : altered)\n      }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0]\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, contentSize, false)\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, -contentSize, true)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, slideLocation } = loopPoint\n      const shiftLocation = target()\n      if (shiftLocation === slideLocation.get()) return\n      translate.to(shiftLocation)\n      slideLocation.set(shiftLocation)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { isBoolean } from './utils'\n\ntype SlidesHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  mutations: MutationRecord[]\n) => boolean | void\n\nexport type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType\n\nexport type SlidesHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function SlidesHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  watchSlides: SlidesHandlerOptionType\n): SlidesHandlerType {\n  let mutationObserver: MutationObserver\n  let destroyed = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchSlides) return\n\n    function defaultCallback(mutations: MutationRecord[]): void {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          emblaApi.reInit()\n          eventHandler.emit('slidesChanged')\n          break\n        }\n      }\n    }\n\n    mutationObserver = new MutationObserver((mutations) => {\n      if (destroyed) return\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations)\n      }\n    })\n\n    mutationObserver.observe(container, { childList: true })\n  }\n\n  function destroy(): void {\n    if (mutationObserver) mutationObserver.disconnect()\n    destroyed = true\n  }\n\n  const self: SlidesHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EventHandlerType } from './EventHandler'\nimport { objectKeys } from './utils'\n\ntype IntersectionEntryMapType = {\n  [key: number]: IntersectionObserverEntry\n}\n\nexport type SlidesInViewOptionsType = IntersectionObserverInit['threshold']\n\nexport type SlidesInViewType = {\n  init: () => void\n  destroy: () => void\n  get: (inView?: boolean) => number[]\n}\n\nexport function SlidesInView(\n  container: HTMLElement,\n  slides: HTMLElement[],\n  eventHandler: EventHandlerType,\n  threshold: SlidesInViewOptionsType\n): SlidesInViewType {\n  const intersectionEntryMap: IntersectionEntryMapType = {}\n  let inViewCache: number[] | null = null\n  let notInViewCache: number[] | null = null\n  let intersectionObserver: IntersectionObserver\n  let destroyed = false\n\n  function init(): void {\n    intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        if (destroyed) return\n\n        entries.forEach((entry) => {\n          const index = slides.indexOf(<HTMLElement>entry.target)\n          intersectionEntryMap[index] = entry\n        })\n\n        inViewCache = null\n        notInViewCache = null\n        eventHandler.emit('slidesInView')\n      },\n      {\n        root: container.parentElement,\n        threshold\n      }\n    )\n\n    slides.forEach((slide) => intersectionObserver.observe(slide))\n  }\n\n  function destroy(): void {\n    if (intersectionObserver) intersectionObserver.disconnect()\n    destroyed = true\n  }\n\n  function createInViewList(inView: boolean): number[] {\n    return objectKeys(intersectionEntryMap).reduce(\n      (list: number[], slideIndex) => {\n        const index = parseInt(slideIndex)\n        const { isIntersecting } = intersectionEntryMap[index]\n        const inViewMatch = inView && isIntersecting\n        const notInViewMatch = !inView && !isIntersecting\n\n        if (inViewMatch || notInViewMatch) list.push(index)\n        return list\n      },\n      []\n    )\n  }\n\n  function get(inView: boolean = true): number[] {\n    if (inView && inViewCache) return inViewCache\n    if (!inView && notInViewCache) return notInViewCache\n\n    const slideIndexes = createInViewList(inView)\n\n    if (inView) inViewCache = slideIndexes\n    if (!inView) notInViewCache = slideIndexes\n\n    return slideIndexes\n  }\n\n  const self: SlidesInViewType = {\n    init,\n    destroy,\n    get\n  }\n\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport {\n  arrayKeys,\n  arrayLast,\n  arrayLastIndex,\n  isNumber,\n  mathAbs\n} from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  axis: AxisType,\n  viewSize: number,\n  slidesToScroll: SlidesToScrollOptionType,\n  loop: boolean,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  startGap: number,\n  endGap: number,\n  pixelTolerance: number\n): SlidesToScrollType {\n  const { startEdge, endEdge, direction } = axis\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    if (!array.length) return []\n\n    return arrayKeys(array)\n      .reduce((groups: number[], rectB, index) => {\n        const rectA = arrayLast(groups) || 0\n        const isFirst = rectA === 0\n        const isLast = rectB === arrayLastIndex(array)\n\n        const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge]\n        const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge]\n        const gapA = !loop && isFirst ? direction(startGap) : 0\n        const gapB = !loop && isLast ? direction(endGap) : 0\n        const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA))\n\n        if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB)\n        if (isLast) groups.push(array.length)\n        return groups\n      }, [])\n      .map((currentSize, index, groups) => {\n        const previousSize = Math.max(groups[index - 1] || 0)\n        return array.slice(previousSize, currentSize)\n      })\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport {\n  Animations,\n  AnimationsType,\n  AnimationsUpdateType,\n  AnimationsRenderType\n} from './Animations'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { NodeRectType, NodeRects } from './NodeRects'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ResizeHandler, ResizeHandlerType } from './ResizeHandler'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { SlideRegistry, SlideRegistryType } from './SlideRegistry'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideFocus, SlideFocusType } from './SlideFocus'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesHandler, SlidesHandlerType } from './SlidesHandler'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex, WindowType } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  ownerDocument: Document\n  ownerWindow: WindowType\n  eventHandler: EventHandlerType\n  axis: AxisType\n  animation: AnimationsType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  offsetLocation: Vector1DType\n  previousLocation: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  resizeHandler: ResizeHandlerType\n  slidesHandler: SlidesHandlerType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnapList: number[]\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  slideFocus: SlideFocusType\n  slideRegistry: SlideRegistryType['slideRegistry']\n  containerRect: NodeRectType\n  slideRects: NodeRectType[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  options: OptionsType,\n  eventHandler: EventHandlerType\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag,\n    watchFocus\n  } = options\n\n  // Measurements\n  const pixelTolerance = 2\n  const nodeRects = NodeRects()\n  const containerRect = nodeRects.measure(container)\n  const slideRects = slides.map(nodeRects.measure)\n  const axis = Axis(scrollAxis, direction)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && !!containScroll\n  const readEdgeGap = loop || !!containScroll\n  const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n    ownerWindow\n  )\n  const slidesToScroll = SlidesToScroll(\n    axis,\n    viewSize,\n    groupSlides,\n    loop,\n    containerRect,\n    slideRects,\n    startGap,\n    endGap,\n    pixelTolerance\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slidesToScroll\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained, scrollContainLimit } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n    pixelTolerance\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Animation\n  const update: AnimationsUpdateType = ({\n    dragHandler,\n    scrollBody,\n    scrollBounds,\n    options: { loop }\n  }) => {\n    if (!loop) scrollBounds.constrain(dragHandler.pointerDown())\n    scrollBody.seek()\n  }\n\n  const render: AnimationsRenderType = (\n    {\n      scrollBody,\n      translate,\n      location,\n      offsetLocation,\n      previousLocation,\n      scrollLooper,\n      slideLooper,\n      dragHandler,\n      animation,\n      eventHandler,\n      scrollBounds,\n      options: { loop }\n    },\n    alpha\n  ) => {\n    const shouldSettle = scrollBody.settled()\n    const withinBounds = !scrollBounds.shouldConstrain()\n    const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds\n\n    if (hasSettled && !dragHandler.pointerDown()) {\n      animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!hasSettled) eventHandler.emit('scroll')\n\n    const interpolatedLocation =\n      location.get() * alpha + previousLocation.get() * (1 - alpha)\n\n    offsetLocation.set(interpolatedLocation)\n\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction())\n      slideLooper.loop()\n    }\n\n    translate.to(offsetLocation.get())\n  }\n\n  const animation = Animations(\n    ownerDocument,\n    ownerWindow,\n    () => update(engine),\n    (alpha: number) => render(engine, alpha)\n  )\n\n  // Shared\n  const friction = 0.68\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const previousLocation = Vector1D(startLocation)\n  const offsetLocation = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(\n    location,\n    offsetLocation,\n    previousLocation,\n    target,\n    duration,\n    friction\n  )\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollBody,\n    scrollTarget,\n    target,\n    eventHandler\n  )\n  const scrollProgress = ScrollProgress(limit)\n  const eventStore = EventStore()\n  const slidesInView = SlidesInView(\n    container,\n    slides,\n    eventHandler,\n    inViewThreshold\n  )\n  const { slideRegistry } = SlideRegistry(\n    containSnaps,\n    containScroll,\n    scrollSnaps,\n    scrollContainLimit,\n    slidesToScroll,\n    slideIndexes\n  )\n  const slideFocus = SlideFocus(\n    root,\n    slides,\n    slideRegistry,\n    scrollTo,\n    scrollBody,\n    eventStore,\n    eventHandler,\n    watchFocus\n  )\n\n  // Engine\n  const engine: EngineType = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    dragHandler: DragHandler(\n      axis,\n      root,\n      ownerDocument,\n      ownerWindow,\n      target,\n      DragTracker(axis, ownerWindow),\n      location,\n      animation,\n      scrollTo,\n      scrollBody,\n      scrollTarget,\n      index,\n      eventHandler,\n      percentOfView,\n      dragFree,\n      dragThreshold,\n      skipSnaps,\n      friction,\n      watchDrag\n    ),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(\n      container,\n      eventHandler,\n      ownerWindow,\n      slides,\n      axis,\n      watchResize,\n      nodeRects\n    ),\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      offsetLocation,\n      target,\n      scrollBody,\n      percentOfView\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n      location,\n      offsetLocation,\n      previousLocation,\n      target\n    ]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizes,\n      slideSizesWithGaps,\n      snaps,\n      scrollSnaps,\n      offsetLocation,\n      slides\n    ),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, container)\n  }\n\n  return engine\n}\n","export type NodeRectType = {\n  top: number\n  right: number\n  bottom: number\n  left: number\n  width: number\n  height: number\n}\n\nexport type NodeRectsType = {\n  measure: (node: HTMLElement) => NodeRectType\n}\n\nexport function NodeRects(): NodeRectsType {\n  function measure(node: HTMLElement): NodeRectType {\n    const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node\n    const offset: NodeRectType = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    }\n\n    return offset\n  }\n\n  const self: NodeRectsType = {\n    measure\n  }\n  return self\n}\n","import { NodeRectType } from './NodeRects'\n\nexport type AxisOptionType = 'x' | 'y'\nexport type AxisDirectionOptionType = 'ltr' | 'rtl'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (nodeRect: NodeRectType) => number\n  direction: (n: number) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: AxisDirectionOptionType\n): AxisType {\n  const isRightToLeft = contentDirection === 'rtl'\n  const isVertical = axis === 'y'\n  const scroll = isVertical ? 'y' : 'x'\n  const cross = isVertical ? 'x' : 'y'\n  const sign = !isVertical && isRightToLeft ? -1 : 1\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(nodeRect: NodeRectType): number {\n    const { height, width } = nodeRect\n    return isVertical ? height : width\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (isVertical) return 'top'\n    return isRightToLeft ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (isVertical) return 'bottom'\n    return isRightToLeft ? 'left' : 'right'\n  }\n\n  function direction(n: number): number {\n    return n * sign\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n    direction\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure\n  }\n  return self\n}\n","import { isString } from './utils'\n\nexport type AlignmentOptionType =\n  | 'start'\n  | 'center'\n  | 'end'\n  | ((viewSize: number, snapSize: number, index: number) => number)\n\nexport type AlignmentType = {\n  measure: (n: number, index: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function measure(n: number, index: number): number {\n    if (isString(align)) return predefined[align](n)\n    return align(viewSize, n, index)\n  }\n\n  const self: AlignmentType = {\n    measure\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { arrayIsLastIndex, arrayLast, mathAbs, WindowType } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n  startGap: number\n  endGap: number\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n  ownerWindow: WindowType\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = ownerWindow.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(rects, index)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slidesToScroll: SlidesToScrollType\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayIsLastIndex, arrayLast, deltaAbs } from './utils'\n\nexport type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n  scrollContainLimit: LimitType\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n  pixelTolerance: number\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, 0)\n  const snapsBounded = measureBounded()\n  const scrollContainLimit = findScrollContainLimit()\n  const snapsContained = measureContained()\n\n  function usePixelTolerance(bound: number, snap: number): boolean {\n    return deltaAbs(bound, snap) < 1\n  }\n\n  function findScrollContainLimit(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureBounded(): number[] {\n    return snapsAligned\n      .map((snapAligned, index) => {\n        const { min, max } = scrollBounds\n        const snap = scrollBounds.constrain(snapAligned)\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(snapsAligned, index)\n        if (isFirst) return max\n        if (isLast) return min\n        if (usePixelTolerance(min, snap)) return min\n        if (usePixelTolerance(max, snap)) return max\n        return snap\n      })\n      .map((scrollBound) => parseFloat(scrollBound.toFixed(3)))\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = scrollContainLimit\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n    scrollContainLimit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean\n): ScrollLimitType {\n  const max = scrollSnaps[0]\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps)\n  const limit = Limit(min, max)\n\n  const self: ScrollLimitType = {\n    limit\n  }\n  return self\n}\n","import { mathSign, mathAbs } from './utils'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  duration: () => number\n  velocity: () => number\n  seek: () => ScrollBodyType\n  settled: () => boolean\n  useBaseFriction: () => ScrollBodyType\n  useBaseDuration: () => ScrollBodyType\n  useFriction: (n: number) => ScrollBodyType\n  useDuration: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  offsetLocation: Vector1DType,\n  previousLocation: Vector1DType,\n  target: Vector1DType,\n  baseDuration: number,\n  baseFriction: number\n): ScrollBodyType {\n  let scrollVelocity = 0\n  let scrollDirection = 0\n  let scrollDuration = baseDuration\n  let scrollFriction = baseFriction\n  let rawLocation = location.get()\n  let rawLocationPrevious = 0\n\n  function seek(): ScrollBodyType {\n    const displacement = target.get() - location.get()\n    const isInstant = !scrollDuration\n    let scrollDistance = 0\n\n    if (isInstant) {\n      scrollVelocity = 0\n      previousLocation.set(target)\n      location.set(target)\n\n      scrollDistance = displacement\n    } else {\n      previousLocation.set(location)\n\n      scrollVelocity += displacement / scrollDuration\n      scrollVelocity *= scrollFriction\n      rawLocation += scrollVelocity\n      location.add(scrollVelocity)\n\n      scrollDistance = rawLocation - rawLocationPrevious\n    }\n\n    scrollDirection = mathSign(scrollDistance)\n    rawLocationPrevious = rawLocation\n    return self\n  }\n\n  function settled(): boolean {\n    const diff = target.get() - offsetLocation.get()\n    return mathAbs(diff) < 0.001\n  }\n\n  function duration(): number {\n    return scrollDuration\n  }\n\n  function direction(): number {\n    return scrollDirection\n  }\n\n  function velocity(): number {\n    return scrollVelocity\n  }\n\n  function useBaseDuration(): ScrollBodyType {\n    return useDuration(baseDuration)\n  }\n\n  function useBaseFriction(): ScrollBodyType {\n    return useFriction(baseFriction)\n  }\n\n  function useDuration(n: number): ScrollBodyType {\n    scrollDuration = n\n    return self\n  }\n\n  function useFriction(n: number): ScrollBodyType {\n    scrollFriction = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  }\n  return self\n}\n","import { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationsType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    targetVector.add(distanceDiff)\n\n    if (distanceDiff) {\n      if (scrollBody.duration()) {\n        animation.start()\n      } else {\n        animation.update()\n        animation.render(1)\n        animation.update()\n      }\n    }\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return length ? currentLocation / -length : 0\n  }\n\n  const self: ScrollProgressType = {\n    get\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport {\n  arrayFromNumber,\n  arrayIsLastIndex,\n  arrayLast,\n  arrayLastIndex\n} from './utils'\n\nexport type SlideRegistryType = {\n  slideRegistry: number[][]\n}\n\nexport function SlideRegistry(\n  containSnaps: boolean,\n  containScroll: ScrollContainOptionType,\n  scrollSnaps: number[],\n  scrollContainLimit: LimitType,\n  slidesToScroll: SlidesToScrollType,\n  slideIndexes: number[]\n): SlideRegistryType {\n  const { groupSlides } = slidesToScroll\n  const { min, max } = scrollContainLimit\n  const slideRegistry = createSlideRegistry()\n\n  function createSlideRegistry(): number[][] {\n    const groupedSlideIndexes = groupSlides(slideIndexes)\n    const doNotContain = !containSnaps || containScroll === 'keepSnaps'\n\n    if (scrollSnaps.length === 1) return [slideIndexes]\n    if (doNotContain) return groupedSlideIndexes\n\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index\n      const isLast = arrayIsLastIndex(groups, index)\n\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1\n        return arrayFromNumber(range)\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1\n        return arrayFromNumber(range, arrayLast(groups)[0])\n      }\n      return group\n    })\n  }\n\n  const self: SlideRegistryType = {\n    slideRegistry\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisDirectionOptionType, AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { DragHandlerOptionType } from './DragHandler'\nimport { ResizeHandlerOptionType } from './ResizeHandler'\nimport { SlidesHandlerOptionType } from './SlidesHandler'\nimport { SlidesInViewOptionsType } from './SlidesInView'\nimport { FocusHandlerOptionType } from './SlideFocus'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  container: string | HTMLElement | null\n  slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null\n  containScroll: ScrollContainOptionType\n  direction: AxisDirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  dragThreshold: number\n  inViewThreshold: SlidesInViewOptionsType\n  loop: boolean\n  skipSnaps: boolean\n  duration: number\n  startIndex: number\n  watchDrag: DragHandlerOptionType\n  watchResize: ResizeHandlerOptionType\n  watchSlides: SlidesHandlerOptionType\n  watchFocus: FocusHandlerOptionType\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: 'trimSnaps',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true,\n  watchFocus: true\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsMergeDeep, WindowType } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ) => TypeA\n  optionsAtMedia: <Type extends OptionsType>(options: Type) => Type\n  optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[]\n}\n\nexport function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType {\n  function mergeOptions<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function optionsAtMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => ownerWindow.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => mergeOptions(a, mediaOption), {})\n\n    return mergeOptions(options, matchedMediaOptions)\n  }\n\n  function optionsMediaQueries(optionsList: OptionsType[]): MediaQueryList[] {\n    return optionsList\n      .map((options) => objectKeys(options.breakpoints || {}))\n      .reduce((acc, mediaQueries) => acc.concat(mediaQueries), [])\n      .map(ownerWindow.matchMedia)\n  }\n\n  const self: OptionsHandlerType = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType, OptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\nimport { isString, WindowType } from './utils'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  emit: EventHandlerType['emit']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: () => number[]\n  slidesNotInView: () => number[]\n}\n\nfunction EmblaCarousel(\n  root: HTMLElement,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[]\n): EmblaCarouselType {\n  const ownerDocument = root.ownerDocument\n  const ownerWindow = <WindowType>ownerDocument.defaultView\n  const optionsHandler = OptionsHandler(ownerWindow)\n  const pluginsHandler = PluginsHandler(optionsHandler)\n  const mediaHandlers = EventStore()\n  const eventHandler = EventHandler()\n  const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler\n  const { on, off, emit } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions)\n  let options = mergeOptions(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const { container: userContainer, slides: userSlides } = options\n\n    const customContainer = isString(userContainer)\n      ? root.querySelector(userContainer)\n      : userContainer\n    container = <HTMLElement>(customContainer || root.children[0])\n\n    const customSlides = isString(userSlides)\n      ? container.querySelectorAll(userSlides)\n      : userSlides\n    slides = <HTMLElement[]>[].slice.call(customSlides || container.children)\n  }\n\n  function createEngine(options: OptionsType): EngineType {\n    const engine = Engine(\n      root,\n      container,\n      slides,\n      ownerDocument,\n      ownerWindow,\n      options,\n      eventHandler\n    )\n\n    if (options.loop && !engine.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options, { loop: false })\n      return createEngine(optionsWithoutLoop)\n    }\n    return engine\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    if (destroyed) return\n\n    optionsBase = mergeOptions(optionsBase, withOptions)\n    options = optionsAtMedia(optionsBase)\n    pluginList = withPlugins || pluginList\n\n    storeElements()\n\n    engine = createEngine(options)\n\n    optionsMediaQueries([\n      optionsBase,\n      ...pluginList.map(({ options }) => options)\n    ]).forEach((query) => mediaHandlers.add(query, 'change', reActivate))\n\n    if (!options.active) return\n\n    engine.translate.to(engine.location.get())\n    engine.animation.init()\n    engine.slidesInView.init()\n    engine.slideFocus.init(self)\n    engine.eventHandler.init(self)\n    engine.resizeHandler.init(self)\n    engine.slidesHandler.init(self)\n\n    if (engine.options.loop) engine.slideLooper.loop()\n    if (container.offsetParent && slides.length) engine.dragHandler.init(self)\n\n    pluginApis = pluginsHandler.init(self, pluginList)\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(mergeOptions({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.destroy()\n    engine.eventStore.clear()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    engine.resizeHandler.destroy()\n    engine.slidesHandler.destroy()\n    engine.slidesInView.destroy()\n    engine.animation.destroy()\n    pluginsHandler.destroy()\n    mediaHandlers.clear()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    mediaHandlers.clear()\n    deActivate()\n    eventHandler.emit('destroy')\n    eventHandler.clear()\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody\n      .useBaseFriction()\n      .useDuration(jump === true ? 0 : options.duration)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.add(1).get()\n    scrollTo(next, jump, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.add(-1).get()\n    scrollTo(prev, jump, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.add(1).get()\n    return next !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.add(-1).get()\n    return prev !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnapList\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function slidesInView(): number[] {\n    return engine.slidesInView.get()\n  }\n\n  function slidesNotInView(): number[] {\n    return engine.slidesInView.get(false)\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  }\n\n  activate(userOptions, userPlugins)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\ndeclare namespace EmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nEmblaCarousel.globalOptions = undefined\n\nexport default EmblaCarousel\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { OptionsHandlerType } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type PluginsHandlerType = {\n  init: (\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ) => EmblaPluginsType\n  destroy: () => void\n}\n\nexport function PluginsHandler(\n  optionsHandler: OptionsHandlerType\n): PluginsHandlerType {\n  let activePlugins: EmblaPluginType[] = []\n\n  function init(\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ): EmblaPluginsType {\n    activePlugins = plugins.filter(\n      ({ options }) => optionsHandler.optionsAtMedia(options).active !== false\n    )\n    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler))\n\n    return plugins.reduce(\n      (map, plugin) => Object.assign(map, { [plugin.name]: plugin }),\n      {}\n    )\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\n\ntype CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType = EmblaEventListType[keyof EmblaEventListType]\n\nexport interface EmblaEventListType {\n  init: 'init'\n  pointerDown: 'pointerDown'\n  pointerUp: 'pointerUp'\n  slidesChanged: 'slidesChanged'\n  slidesInView: 'slidesInView'\n  scroll: 'scroll'\n  select: 'select'\n  settle: 'settle'\n  destroy: 'destroy'\n  reInit: 'reInit'\n  resize: 'resize'\n  slideFocusStart: 'slideFocusStart'\n  slideFocus: 'slideFocus'\n}\n\nexport type EventHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  clear: () => void\n}\n\nexport function EventHandler(): EventHandlerType {\n  let listeners: ListenersType = {}\n  let api: EmblaCarouselType\n\n  function init(emblaApi: EmblaCarouselType): void {\n    api = emblaApi\n  }\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(api, evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  function clear(): void {\n    listeners = {}\n  }\n\n  const self: EventHandlerType = {\n    init,\n    emit,\n    off,\n    on,\n    clear\n  }\n  return self\n}\n","import { useRef, useEffect, useState, useCallback } from 'react'\nimport {\n  areOptionsEqual,\n  arePluginsEqual,\n  canUseDOM\n} from 'embla-carousel-reactive-utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType\n} from 'embla-carousel'\n\nexport type EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = []\n): UseEmblaCarouselType {\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [emblaApi, setEmblaApi] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current)\n  }, [emblaApi])\n\n  useEffect(() => {\n    if (areOptionsEqual(storedOptions.current, options)) return\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmblaApi = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current\n      )\n      setEmblaApi(newEmblaApi)\n      return () => newEmblaApi.destroy()\n    } else {\n      setEmblaApi(undefined)\n    }\n  }, [viewport, setEmblaApi])\n\n  return [<EmblaViewportRefType>setViewport, emblaApi]\n}\n\ndeclare namespace useEmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nuseEmblaCarousel.globalOptions = undefined\n\nexport default useEmblaCarousel\n"],"names":["ArrowLeft","createLucideIcon","d","key","ArrowRight","ChevronDown","Search","cx","cy","r","AVATAR_NAME","createAvatarContext","createAvatarScope","createContextScope","AvatarProvider","useAvatarContext","Avatar","React","props","forwardedRef","__scopeAvatar","avatarProps","imageLoadingStatus","setImageLoadingStatus","jsx","scope","onImageLoadingStatusChange","children","Primitive","span","ref","displayName","IMAGE_NAME","AvatarImage","src","onLoadingStatusChange","imageProps","context","referrerPolicy","loadingStatus","setLoadingStatus","useLayoutEffect","isMounted","image","window","Image","updateStatus","status","onload","onerror","useImageLoadingStatus","handleLoadingStatusChange","useCallbackRef","img","FALLBACK_NAME","AvatarFallback","delayMs","fallbackProps","canRender","setCanRender","timerId","setTimeout","clearTimeout","Root","Fallback","composeRefs","_len","arguments","length","refs","Array","_key","node","forEach","value","current","setRef","useComposedRefs","_len2","_key2","scopeName","createContextScopeDeps","undefined","defaultContexts","createScope","scopeContexts","map","defaultContext","contexts","rootComponentName","BaseContext","index","Provider","Context","Object","values","consumerName","Error","composeContextScopes","scopes","baseScope","scopeHooks","createScope2","useScope","overrideScopes","nextScopes","reduce","nextScopes2","_ref","composeEventHandlers","originalEventHandler","ourEventHandler","checkForDefaultPrevented","event","defaultPrevented","useControllableState","prop","defaultProp","onChange","uncontrolledProp","setUncontrolledProp","_ref2","uncontrolledState","prevValueRef","handleChange","useUncontrolledState","isControlled","nextValue","value2","DirectionContext","Presence","present","presence","setNode","React2","stylesRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","machine","useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","currentAnimationName","getAnimationName","styles","wasPresent","prevAnimationName","display","timeoutId","ownerWindow","ownerDocument","defaultView","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","currentFillMode","style","animationFillMode","handleAnimationStart","addEventListener","removeEventListener","isPresent","node2","getComputedStyle","usePresence","child","only","element","getter","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","getElementRef","useReactId","toString","count","useId","deterministicId","id","setId","reactId","String","createCollection","name","PROVIDER_NAME","createCollectionContext","createCollectionScope","CollectionProviderImpl","useCollectionContext","collectionRef","itemMap","Map","CollectionProvider","COLLECTION_SLOT_NAME","CollectionSlot","composedRefs","Slot","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlot","itemData","set","delete","ItemSlot","collectionNode","orderedNodes","from","querySelectorAll","sort","a","b","indexOf","originalBodyPointerEvents","CONTEXT_UPDATE","POINTER_DOWN_OUTSIDE","FOCUS_OUTSIDE","DismissableLayerContext","layers","Set","layersWithOutsidePointerEventsDisabled","branches","DismissableLayer","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss","layerProps","globalThis","document","force","highestLayerWithOutsidePointerEventsDisabled","slice","highestLayerWithOutsidePointerEventsDisabledIndex","isBodyPointerEventsDisabled","size","isPointerEventsEnabled","pointerDownOutside","handlePointerDownOutside","isPointerInsideReactTreeRef","handleClickRef","handlePointerDown","handleAndDispatchPointerDownOutsideEvent2","handleAndDispatchCustomEvent","eventDetail","discrete","originalEvent","pointerType","once","onPointerDownCapture","usePointerDownOutside","isPointerDownOnBranch","some","branch","contains","focusOutside","handleFocusOutside","isFocusInsideReactTreeRef","handleFocus","onFocusCapture","onBlurCapture","useFocusOutside","onEscapeKeyDownProp","handleKeyDown","capture","useEscapeKeydown","preventDefault","body","pointerEvents","add","dispatchUpdate","handleUpdate","div","DismissableLayerBranch","CustomEvent","dispatchEvent","handler","detail","bubbles","cancelable","dispatchDiscreteCustomEvent","usePrevious","previous","VisuallyHidden","position","border","width","height","padding","margin","overflow","clip","whiteSpace","wordWrap","NAVIGATION_MENU_NAME","Collection","useCollection","FocusGroupCollection","useFocusGroupCollection","createFocusGroupCollectionScope","createNavigationMenuContext","createNavigationMenuScope","NavigationMenuProviderImpl","useNavigationMenuContext","ViewportContentProvider","useViewportContentContext","NavigationMenu","__scopeNavigationMenu","valueProp","onValueChange","defaultValue","delayDuration","skipDelayDuration","orientation","dir","NavigationMenuProps","navigationMenu","setNavigationMenu","composedRef","direction","localDir","globalDir","useDirection","openTimerRef","closeTimerRef","skipDelayTimerRef","isOpenDelayed","setIsOpenDelayed","setValue","hasSkipDelayDuration","startCloseTimer","handleOpen","itemValue","handleDelayedOpen","NavigationMenuProvider","isRootMenu","rootNavigationMenu","onTriggerEnter","onTriggerLeave","onContentEnter","onContentLeave","onItemSelect","prevValue","onItemDismiss","nav","SUB_NAME","NavigationMenuSub","subProps","viewport","setViewport","viewportContent","setViewportContent","indicatorTrack","setIndicatorTrack","previousValue","baseId","onViewportChange","onIndicatorTrackChange","onViewportContentChange","contentValue","contentData","prevContent","onViewportContentRemove","has","items","LIST_NAME","NavigationMenuList","listProps","list","ul","FocusGroup","asChild","ITEM_NAME","NavigationMenuItemContextProvider","useNavigationMenuItemContext","NavigationMenuItem","itemProps","autoValue","contentRef","triggerRef","focusProxyRef","restoreContentTabOrderRef","wasEscapeCloseRef","handleContentEntry","side","candidates","getTabbableCandidates","focusFirst","reverse","handleContentExit","candidate","dataset","tabindex","getAttribute","setAttribute","prevTabIndex","removeFromTabOrder","onEntryKeyDown","onFocusProxyEnter","onRootContentClose","onContentFocusOutside","li","TRIGGER_NAME","NavigationMenuTrigger","disabled","triggerProps","itemContext","triggerId","makeTriggerId","contentId","makeContentId","hasPointerMoveOpenedRef","wasClickCloseRef","open","jsxs","Fragment","FocusGroupItem","button","getOpenState","onPointerEnter","onPointerMove","whenMouse","onPointerLeave","onClick","onKeyDown","entryKey","horizontal","vertical","VisuallyHiddenPrimitive","tabIndex","onFocus","content","prevFocusedElement","relatedTarget","wasTriggerFocused","wasFocusFromContent","LINK_SELECT","NavigationMenuLink","active","onSelect","linkProps","linkSelectEvent","event2","metaKey","rootContentDismissEvent","ROOT_CONTENT_DISMISS","INDICATOR_NAME","NavigationMenuIndicator","forceMount","indicatorProps","isVisible","Boolean","ReactDOM","NavigationMenuIndicatorImpl","getItems","activeTrigger","setActiveTrigger","setPosition","isHorizontal","triggerNode","find","item","handlePositionChange","offsetWidth","offsetHeight","offset","offsetLeft","offsetTop","useResizeObserver","left","transform","top","CONTENT_NAME","NavigationMenuContent","contentProps","commonProps","ViewportContentMounter","NavigationMenuContentImpl","prevMotionAttributeRef","handleClose","activeElement","focus","motionAttribute","prevIndex","isSelected","wasSelected","attribute","Event","isTrigger","isRootViewport","isMetaKey","altKey","ctrlKey","currentTarget","focusedElement","findIndex","shiftKey","VIEWPORT_NAME","NavigationMenuViewport","viewportProps","NavigationMenuViewportImpl","viewportImplProps","viewportContentContext","setSize","setContent","viewportWidth","viewportHeight","activeContentValue","handleSizeChange","props2","isActive","groupProps","ARROW_KEYS","candidateNodes","currentIndex","container","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","previouslyFocusedElement","onResize","handleResize","rAF","resizeObserver","ResizeObserver","cancelAnimationFrame","requestAnimationFrame","observe","unobserve","Root2","List","Item","Trigger","Link","Indicator","Content","Viewport","primitive","Node","primitiveProps","Comp","Symbol","for","slotProps","childrenArray","toArray","slottable","isSlottable","newElement","newChildren","SlotClone","childrenRef","mergeProps","Slottable","childProps","overrideProps","propName","slotPropValue","childPropValue","test","filter","join","callback","callbackRef","args","useLayoutEffect2","e","t","f","n","isArray","clsx","isRecord","subject","prototype","call","isObject","areOptionsEqual","optionsA","optionsB","optionsAKeys","keys","optionsBKeys","JSON","stringify","breakpoints","every","valueA","valueB","sortAndMapPluginToOptions","plugins","concat","plugin","options","isNumber","isString","isBoolean","mathAbs","Math","abs","mathSign","sign","deltaAbs","arrayKeys","array","objectKeys","Number","arrayLast","arrayLastIndex","max","arrayIsLastIndex","arrayFromNumber","startAt","_","i","object","objectsMergeDeep","objectA","objectB","mergedObjects","currentObject","areObjects","isMouseEvent","evt","MouseEvent","EventStore","listeners","self","removeListener","passive","legacyMediaQueryList","addListener","clear","remove","Animations","update","render","documentVisibleHandler","fixedTimeStep","lastTimeStamp","accumulatedTime","animationId","animate","timeStamp","timeElapsed","stop","init","destroy","start","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","clone","DragHandler","axis","rootNode","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","eventHandler","percentOfView","dragFree","dragThreshold","skipSnaps","baseFriction","watchDrag","cross","crossAxis","focusNodes","nonPassiveEvent","initEvents","dragEvents","goToNextThreshold","measure","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","isMoving","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","move","touches","up","lastScroll","readPoint","lastCross","diffScroll","diffCross","diff","pointerMove","useFriction","useDuration","targetChanged","byDistance","rawForce","pointerUp","next","baseForce","distance","byIndex","allowedForce","forceFactor","factorAbs","speed","friction","emit","click","stopPropagation","emblaApi","downIfAllowed","isMouseEvt","buttons","nodeName","isFocusNode","pointerDown","addDragEvents","down","DragTracker","startEvent","lastEvent","readTime","evtAxis","coord","scroll","expired","diffDrag","diffTime","ResizeHandler","slides","watchResize","nodeRects","observeNodes","containerSize","slideSizes","destroyed","readSize","measureSize","entries","entry","isContainer","slideIndex","lastSize","reInit","defaultCallback","disconnect","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","frictionLimit","shouldConstrain","edge","diffToEdge","diffToTarget","subtract","useBaseFriction","toggleActive","ScrollLooper","contentSize","vectors","shouldLoop","loopDistance","v","ScrollTarget","scrollSnaps","targetVector","minDistance","distances","shortcut","targets","matchingTargets","snap","targetSnapDistance","ascDiffsToSnaps","d1","d2","findTargetSnap","reachedBound","SlideFocus","root","slideRegistry","eventStore","watchFocus","focusListenerOptions","lastTabPressTime","registerTabPress","code","Date","getTime","slide","scrollLeft","group","Vector1D","initialValue","normalizeInput","Translate","translate","containerStyle","previousTarget","removeAttribute","to","newTarget","num","round","SlideLooper","viewSize","slideSizesWithGaps","snaps","ascItems","descItems","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","removeSlideSizes","indexes","isEndEdge","slideBounds","end","findSlideBounds","initial","altered","boundEdge","loopPoint","slideLocation","canLoop","shiftLocation","SlidesHandler","watchSlides","mutationObserver","MutationObserver","mutations","mutation","childList","SlidesInView","threshold","intersectionEntryMap","intersectionObserver","inViewCache","notInViewCache","IntersectionObserver","parentElement","inView","slideIndexes","parseInt","isIntersecting","createInViewList","SlidesToScroll","slidesToScroll","containerRect","slideRects","startGap","endGap","pixelTolerance","startEdge","endEdge","groupByNumber","groupSlides","groupSize","byNumber","groups","rectB","rectA","isFirst","isLast","edgeA","edgeB","gapA","chunkSize","currentSize","previousSize","bySize","Engine","align","scrollAxis","startIndex","duration","inViewThreshold","containScroll","right","bottom","contentDirection","isRightToLeft","isVertical","nodeRect","Axis","PercentOfView","alignment","predefined","center","Alignment","containSnaps","readEdgeGap","withEdgeGap","slideRect","measureStartGap","parseFloat","getPropertyValue","measureEndGap","rect","rects","SlideSizes","snapsAligned","alignments","g","ScrollSnaps","snapsContained","scrollContainLimit","scrollBounds","snapsBounded","snapAligned","usePixelTolerance","scrollBound","toFixed","startSnap","endSnap","lastIndexOf","findScrollContainLimit","bound","measureContained","ScrollContain","ScrollLimit","indexPrevious","dragHandler","seek","engine","alpha","_ref3","offsetLocation","previousLocation","scrollLooper","slideLooper","shouldSettle","settled","withinBounds","hasSettled","interpolatedLocation","startLocation","baseDuration","scrollVelocity","scrollDirection","scrollDuration","scrollFriction","rawLocation","rawLocationPrevious","velocity","displacement","scrollDistance","useBaseDuration","ScrollBody","indexCurrent","distanceDiff","indexDiff","targetIndex","ScrollTo","scrollProgress","ScrollProgress","slidesInView","groupedSlideIndexes","doNotContain","createSlideRegistry","SlideRegistry","slideFocus","resizeHandler","scrollSnapList","slidesHandler","defaultOptions","OptionsHandler","mergeOptions","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","optionsMediaQueries","optionsList","acc","mediaQueries","EmblaCarousel","userOptions","userPlugins","optionsHandler","pluginsHandler","activePlugins","_ref4","assign","PluginsHandler","mediaHandlers","api","getListeners","off","cb","on","EventHandler","reActivate","pluginApis","optionsBase","globalOptions","pluginList","createEngine","activate","withOptions","withPlugins","userContainer","userSlides","customContainer","querySelector","customSlides","storeElements","_ref5","query","offsetParent","selectedScrollSnap","deActivate","jump","canScrollNext","canScrollPrev","containerNode","internalEngine","previousScrollSnap","scrollNext","scrollPrev","slideNodes","slidesNotInView","useEmblaCarousel","storedOptions","useRef","storedPlugins","setEmblaApi","useState","useCallback","useEffect","pluginsA","pluginsB","optionA","arePluginsEqual","createElement","newEmblaApi"],"sourceRoot":""}